[{"id":"5f9b4dbbcaf33940a3ac90092e96387c","title":"使用 Verdaccio 搭建 npm 私服","content":"\n\n\n\n\n\n\n\n\nVerdaccio 拉取的包存放地址为本地\nVerdaccio\n安装 Verdaccionpm i -g verdaccio\n\n启动 Verdaccioverdaccio\n\n访问 Verdaccio启动完成之后，Web 服务默认监听在 4873 端口。通过浏览器访问 http://localhost:4873 即可看到私服页面。在启动之后的输出中，会有配置文件的存放位置，默认为： /Users/userName/.config/verdaccio/config.yaml\n打开之后，能够看到 npm 包存放在本地的地址。默认为：\nstorage: /Users/userName/.local/share/verdaccio/storage\n\n访问 Web：\n\n默认没有上传过任何私服的包，并且也没有任何登录用户。\n设置用户\n新增用户npm adduser --register http://localhost:4873输入用户名、密码、邮箱等。\n\n登录 Web 端测试：\n\n发布到私服\n配置发布源\n\n&#123;\n  \"publishConfig\": &#123;\n    \"registry\": \"http://localhost:4873/\"\n  &#125;\n&#125;\n\n\n也可以在 npm publish 的时候指定 register\n\nnpm publish --register http://localhost:4873\n\n使用第一种修改 package.json 中的配置的方式，当包准备好发布时，直接执行 npm publish 就可以发到我们刚搭建的私服上去了。\n测试发布\n我们创建的项目测试下。 npm init -y 静默创建 package.json ，修改 publishConfig 。包名可以使用 scope 的形式。\n\n&#123;\n  \"name\": \"@org/utils\",\n  \"version\": \"1.0.0\",\n  \"description\": \"测试 Verdaccio\",\n  \"main\": \"index.js\",\n  \"scripts\": &#123;\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\"\n  &#125;,\n  \"publishConfig\": &#123;\n    \"registry\": \"http://localhost:4873/\"\n  &#125;,\n  \"keywords\": [],\n  \"author\": \"Zhongkang Shen\",\n  \"license\": \"MIT\"\n&#125;\n\n\n根目录下创建 index.js 文件，内容我们随便写一个函数导出。\n\nexport function twoSum(a, b) &#123;\n  return a + b;\n&#125;\n\n\n因为不需要任何额外依赖，也不需要什么打包配置，我们可以直接执行 npm publish 发布。\n\n\n\n发布成功之后，打开 Web 页面查看。\n\n\n\n因为没有 README.md文件，我们查看包详细信息的时候，是空白的。我们增加一个包的简单说明，然后给这个包升级发布。\n\n修改版本号为 1.0.1 然后执行 npm publish 发布。再次来到 Web 页面：\n\n已经发布成功，并且添加了 README 。在版本中，可以查看到我们发布的历史版本记录。\n\n删除包通过 storage 配置中的地址，访问查看我们本地存储的所有包。直接删除指定的包，就不会在 Web 里查看到了。\n","slug":"build-private-npm-register-with-verdaccio","date":"2023-01-12T09:51:46.000Z","categories_index":"frontend,npm","tags_index":"frontend,node,npm","author_index":"Zhongkang Shen"},{"id":"8bb4189dd0fa7fb30567f50c7f73bb69","title":"ServiceNow Jelly tags","content":"Jelly tags - Jelly 标签Jelly用来将 XML 转换为 HTML。\nJelly 标签if\n描述：if标签如你所见，用来做条件判断的，但是这里需要主要，没有所谓的 elseif和 else标签，如果需要表达否则的这种的判断，请使用 choose&#x2F; when&#x2F; otherwise这些语法。\n参数：\ntest - 放用于判断 if 的条件，用来决定 if 中的内容是否被执行。\n\n\n例子：\n\n&lt;g:evaluate var=\"jvar_now_GR\" object=\"true\">\n  var now_GR = new GlideRecord(\"incident\");\n  now_GR.addQuery(\"active\", true);\n  now_GR.query();\n  nowGR;\n&lt;/g:evaluate>\n\n&lt;j:if test=\"$&#123;!jvar_now_GR.hasNext()&#125;\">\n  We did not find any active incidents.\n&lt;/j:if>\n\n&lt;j:if test=\"$&#123;jvar_now_GR.next()&#125;\">\n  We found $&#123;jvar_now_GR.getRowCount()&#125; active incidents.\n&lt;/j:if>\n\nwhile\n描述：while用来做 while 循环使用。\n参数：\ntest- 用来做 while 循环的终止条件，应该使用 $&#123;&#125;或 $[]包裹，并且能够运算出 true&#x2F; false结果。\n\n\n例子：\n\n&lt;g:evaluate var=\"jvar_now_GR\" object=\"true\">\n\tvar now_GR = new GlideRecord(\"incident\");\n  now_GR.addQuery(\"active\", true);\n  now_GR.query();\n  now_GR;\n&lt;/g:evaluate>\n\n&lt;j:while test=\"$&#123;jvar_now_GR.next()&#125;\">\n\t&lt;a href=\"incident.do?sys_id=$&#123;jvar_now_GR.getValue('sys_id')&#125;\">\n    $&#123;jvar_now_GR.getValue('number')&#125;\n  &lt;/a>\n&lt;/j:while>\n\nset\n描述：set用来设置一个变量。\n参数：\nvar- 要设置的变量，通常为了保持一致性会使用 jvar_作为变量前缀。\nvalue - 要设置的值，通常是动态的表达式用 $&#123;&#125;或 $[]包裹。\ndefaultValue- 当值为空或者 null时填入的默认值。\n\n\n例子：\n\n&lt;j:set var=\"jvar_incident_number\" value=\"$&#123;jvar_now_GR.getValue('number')&#125;\" />\n\nset_if\n描述：有点像三元运算符，符合条件设置对应变量。\n参数：\nvar- 要设置的变量，通常为了保持一致性会使用 jvar_作为变量前缀。\ntest- 执行的条件，应该使用 $&#123;&#125;或 $[]包裹，并且能够运算出 true&#x2F; false结果。\ntrue - 当 test 中表达式为真时设置的值，属于可选参数，如果表达式为真，但没设置这项，那么变量的值也是空的。\nfalse- 当 test中表达式为假时设置的值，可选同上。\n\n\n\nchoose\n描述：choose用来做条件渲染的，类似于大多数编程语言中的 if-elseif-else。内部使用 when和 otherwise标签来指定执行的代码。\n参数：无\n例子：\n\n&lt;j:choose>\n  &lt;j:when test=\"$&#123;jvar_now_GR.getRowCount() $&#123;AMP&#125;lt; 1&#125;\">We found multiple records!&lt;/j:when>\n  &lt;j:when test=\"$&#123;jvar_now_GR.next()&#125;\">We found record $&#123;jvar_now_GR.getValue('number')&#125;&lt;/j:when>\n  &lt;j:otherwise>Sorry, we could not find the record you secified.&lt;/j:otherwise>\n&lt;/j:choose>\n\nwhen\n描述：when在 choose内使用，此标签用法和 if类似，接收一个条件，符合条件时候渲染，不符合的话执行下一个 when或者 otherwise。\n参数：\ntest - 条件，同上述。\n\n\n例子：\n\n&lt;j:choose>\n  &lt;j:when test=\"$&#123;jvar_now_GR.getRowCount() $&#123;AMP&#125;lt; 1&#125;\">We found multiple records!&lt;/j:when>\n  &lt;j:when test=\"$&#123;jvar_now_GR.next()&#125;\">We found record $&#123;jvar_now_GR.getValue('number')&#125;&lt;/j:when>\n  &lt;j:otherwise>Sorry, we could not find the record you specified.&lt;/j:otherwise>\n&lt;/j:choose>\n\notherwise\n描述：可在 choose&#x2F;when&#x2F;otherwise 内使用，作用如同 else或 default语句。\n参数：无\n例子：\n\n&lt;j:choose>\n  &lt;j:when test=\"$&#123;jvar_now_GR.getRowCount() $&#123;AMP&#125;lt; 1&#125;\">We found multiple records!&lt;/j:when>\n  &lt;j:when test=\"$&#123;jvar_now_GR.next()&#125;\">We found record $&#123;jvar_now_GR.getValue('number')&#125;&lt;/j:when>\n  &lt;j:otherwise>Sorry, we could not find the record you specified.&lt;/j:otherwise>\n&lt;/j:choose>\n\nGlide 标签evaluate\n描述：evaluate标签内执行服务端脚本（JavaScript 代码），然后对外暴露出变量给外部使用。因为执行的是服务端脚本，所以作用域和服务端脚本的作用域相同，可以通过脚本调试功能来调试代码。一些服务端脚本可以访问的对象如：全局的业务规则、GlideRecord、GlideSystem以及上下文中的 Jelly 变量（需设置参数 jelly=true）均可在标签内使用。\n参数：\nvar- 对外暴露的变量名。\nobject- 为 true是表示对外输出的是复合对象类型，而不是原始的数据类型（字符串、数字等）。\njelly- 为 true可访问到 jelly 上下文中的变量。\nexpression- 用来运算的表达式，表达式的结果作为对外暴露变量的值。表达式的写的位置有两种，一是用 expression 属性，将语句以字符串形式写在属性上，另一种是将表达式写在开始和闭合标签中间。\n\n\n例子：\n\n&lt;g:evaluate var=\"jvar_now_GR\" object=\"true\">\n  var now_GR = new GlideRecord(\"incident\");\n  now_GR.addQuery(\"active\", \"true\");\n  now_GR.query();\n  now_GR; // this is the variable put into the variable jvar_now_GR\n&lt;/g:evaluate>\n\n&lt;g:evaluate var=\"jvar_now_GR\" object=\"true\" expression=\"\n  var now_GR = new GlideRecord('incident');\n  now_GR.addQuery('active', 'true');\n  now_GR.query();\n  now_GR; // this is the variable put into the variable jvar_now_GR\" />\n\nmessages\n描述：用来做国际化翻译的。当 gs.getMessage()在页面里被调用时，会在两个地方查找对应文案的翻译结果，一是当前页面的本地缓存（本地国际化对照对象）中，二是页面会发送 AJAX 请求从服务端查询翻译结果，g:messages就是用来把翻译存本地的。\n参数：无\n例子：\n\n&lt;g:messages>\n  Yes\n  No\n  Cancel\n&lt;/g:messages>\n\nbreakpoint\n描述：用以调试，执行到此标签时，会打印出当前运行时下，Jelly 上下文中的变量和实时的值。当指定变量名时，仅打印出指定的变量和值。打印的内容在系统日志中查看。\n参数：\nvar- 可选，指定打印输出的变量名，没指定的话，所有上下文中的变量都会被输出到日志中。\n\n\n例子：\n\n&lt;g:breakpoint />\n\n&lt;g:breakpoint var=\"sysparm_view\"/>\n\nno_escape\n描述：默认情况下，系统对外渲染输出的都是转码的、经过系统转译后的内容，但不排除有一些时候，我们希望写的原始代码被直接输出，有点像 React jsx dangerouslySetInnerHTML的概念，是一个不建议的危险操作，所以这个标签非必要也不建议使用，因为直接不解析就输出用户输入的代码，在安全性上会比较弱。\n参数：无\n例子：\n\n&lt;g:no_escape>\n  $&#123;jvar_raw_html_data&#125;\n&lt;/g:no_escape>\n\nmacro_invoke\n描述：通过此标签可以使用数据库中已经存在的界面宏（定义好的页面元素），有两种方式使用宏，例如有一个宏名字是 my_macro，一种是通过此标签的 macro属性写上宏的名字，还一种是可以直接使用 &lt;g:my_macro /&gt;这种标签形式。\n参数：\nmacro - 需要使用的宏的名字，如果是用 &lt;g:macro_invoke /&gt;形式，这就写宏名字，如果是宏名称作为标签形式，那就无需这个属性了。\n其他属性 - 可以往宏里传属性，作为变量被宏接收，在宏中通过 jvar_的前缀获取变量。\n\n\n例子：\n\n&lt;!-- Will invoke the contents of the UI macro named \"sample_macro\", which will have the variable jvar_message available within it-->\n&lt;g:macro_invoke macro=\"sample_macro\" message=\"This is a sample macro variable.\" />\n\n&lt;!-- Will invoke the contents of the UI macro named \"sample_macro\", which will have the variable jvar_message available within it-->\n&lt;g:sample_macro message=\"This is a sample macro variable.\" />\n\nif_polaris\n描述：此标签是用来判断要渲染的 UI 类型的，polaris是 Now 的下一代 UI 体系的代号。用这个标签来判是否要在当前页面使用新的 UI 形式。此标签必须包含至少一个子标签 &lt;g:then /&gt;或 &lt;g:else /&gt;。\n参数：无\n例子：\n\n&lt;g:if_polaris>\n  &lt;g:then>&lt;g:inline template=\"polaris_nav\"/>&lt;/g:then>\n  &lt;g:else>&lt;g:inline template=\"classic_nav\"/>&lt;/g:else>\n&lt;/g:if_polaris>\n\n&lt;g:if_polaris>\n  &lt;g:then>&lt;a href=\"…\">Click here to see what’s new!&lt;/a>&lt;/g:then>\n&lt;/g:if_polaris>\n\n&lt;g:if_polaris>\n  &lt;g:else>UI16 only code here!&lt;/g:else>\n&lt;/g:if_polaris>\n\nthen\n描述：if_polaris中使用，如果 Next Experience可用的话显示其中内容。\n参数：无\n例子：\n\n&lt;g:if_polaris>\n  &lt;g:then>&lt;g:inline template=\"polaris_nav\"/>&lt;/g:then>\n  &lt;g:else>&lt;g:inline template=\"classic_nav\"/>&lt;/g:else>\n&lt;/g:if_polaris>\n\n&lt;g:if_polaris>\n  &lt;g:then>&lt;a href=\"…\">Click here to see what’s new!&lt;/a>&lt;/g:then>\n&lt;/g:if_polaris>\n\n&lt;g:if_polaris>\n  &lt;g:else>UI16 only code here!&lt;/g:else>\n&lt;/g:if_polaris>\n\nelse\n描述：if_polaris中使用，如果 Next Experience不可用的话显示其中内容。\n参数：无\n例子：\n\n&lt;g:if_polaris>\n  &lt;g:then>&lt;g:inline template=\"polaris_nav\"/>&lt;/g:then>\n  &lt;g:else>&lt;g:inline template=\"classic_nav\"/>&lt;/g:else>\n&lt;/g:if_polaris>\n\n&lt;g:if_polaris>\n  &lt;g:then>&lt;a href=\"…\">Click here to see what’s new!&lt;/a>&lt;/g:then>\n&lt;/g:if_polaris>\n\n&lt;g:if_polaris>\n  &lt;g:else>UI16 only code here!&lt;/g:else>\n&lt;/g:if_polaris>\n\n字符转义\n\n\n类型\n原始\n转义\n\n\n\nJavaScript\n&#39; 单引号\n\\\\&#39;\n\n\n\n&quot; 双引号\n\\\\&quot;\n\n\n\n回车\n空白\n\n\n\n换行\n\\\\n\n\n\nHTML\n&amp;\n&amp;amp;\n\n\n\n&lt;\n&amp;lt;\n\n\n\n&gt;\n&amp;gt;\n\n\nJelly 语法扩展Apache Jelly 语法用来渲染平台中的表单、列表、自定义页面和一些其他的页面元素。通过这种语法和渲染形式，可以通过服务端渲染计算后的页面。\n命名空间j命名是标准 Jelly，g命名是 Now 脚本特有的。\n阶段通常使用 &lt;j&gt; vs &lt;j2&gt; 和 &lt;g&gt;vs &lt;g2&gt;来表示两个阶段。不带 2 的表示发生在 jelly 引擎执行的第一阶段，会被缓存。带 2 的表示不缓存。插值表达式里用 $&#123;&#125; 表示阶段一的，$[] 表示阶段二的。\n","slug":"servicenow-jelly-tags","date":"2022-08-31T06:02:58.000Z","categories_index":"servicenow,article","tags_index":"servicenow,jelly","author_index":"Zhongkang Shen"},{"id":"ef52ea114d19ca53e53c88af8c8e3e36","title":"平民开发者（Citizen Developer）的时代即将来临？（转）","content":"\n\n\n\n\n\n\n\n\n原文地址：平民開發者(Citizen Developer)的時代即將來臨?\n\n重新想象公司的创新动力从 2016 年离开了软件公司之后，在顾问公司工作中开始大量的接触新的技术知识和市场动态，从云端、人工智能、区块链、API 经济、xaaS 到自动化。上述这些流行词为公司巨头们打开了无数个没有硝烟的战场，无论是科技行业、金融行业、制造行业还是医疗产业都摇着数字化转型的大旗迅速的投入大量资源想要通过创新来抢占市场先机。现在推动组织创新的动能，绝大多数还是源自于外部市场的竞争，例如沃尔玛因为亚马逊称霸线上购物而投入大量的资源希望坐稳线下零售龙头的宝座。又或者是迪士尼推出 Disney+ 来应对 Netflix 迅速的全球扩张，但是我认为外部市场的竞争只是海平面上的冰山一角而已，真正还有被开发出的潜在创新动力正是来自于组织内部最重要的资产——员工。\n如果非 IT 人员也能够开发应用系统？从我过去所接触到的人里，大部分的员工其实都有不少优化自己工作流环节的想法，但是想法并无法顺利成型作为一个最小可行性产品来验证，因为当需求移交到 IT 部门手上时，对方经常因为工作排期太满、没有人员支持、使用场景不足等原因延期这些小的需求。最终，这些最了解各个业务环节的专家们提出的大胆假设很少能够被具体的落实下去，而归根结底的核心问题其实就是绝大多数非 IT 员工并不具备足够的开发技能。开发只能交给 IT 人员这件事情在数字爆炸的时代已经不再是唯一的选择，坊间越来越多的工具能够让没有技术或是没有开发背景的非 IT 人员快速地打造出应用程序。而这些新兴的开发者被赋予了一个专有名词，就是平民开发者（Citizen Developer）。平民开发者使用新一代的 Low-Code&#x2F;No-Code（低代码&#x2F;无代码）开发环境，通过拖拽式的用户操作界面，将已经开发好的功能模块、图形组件、系统接口进行组装，搭建出他们自己的业务所需要的应用程序或者是公共服务。可能还是有一部分读者对于平民开发者的趋势持有怀疑态度，那我这里举一个最简单的例子，就是大家耳熟能详的 Excel。在 Excel 或是电子表格软件没有被开发出来之前，人们只能用大量的纸质表格或者是极其复杂的编程语言来完成在现在看起来很简单的计算。而现在大家工作上面很难摆脱的 Excel 或是 Google Sheet 便是一个无代码的典型案例，使用者并不需要具备编程语言的开发经验就可以很快的学习和上手。\n平民开发者是否最终会成为开发人员？学习编程语言对于现在的小孩来说已经不是一个选择项了，泰国的教育局已经有将编程语言作为学生的第三语言的计划，而中国台湾省的少儿&#x2F;青少年编程语言学校也如雨后春笋般的冒出。但是学习简单的编程开发和能够打造一个具有复杂商业逻辑、高度资产安全规范且确保系统高可用性并不是同一件事。要成为一个专业且严谨的开发人员需要多年经验的积累。而且如果你的志向是在金融、会计、销售、生物等其他领域，花大量时间学习编程语言或许并不是你所期望的。但是这并不代表开发相关的技能就能够被忽视。如果你能够运用过去在开发入门课上的所学，再借助先进的低代码开发平台迅速打造一个可以大幅提高工作效率的工具，而这个工具能够作为一个概念验证为公司提供更进一步的延伸和应用，对于组织来说正是内部创新的最好典范。事实上，平民开发者正是那些能够提供初步构想和规划的人，最终再交由技术含量更高的人进一步的优化和完善功能。\n有什么样的低代码&#x2F;无代码平台可以开始学习？Gartner 顾问公司预计在 2024 年的时候，75% 的大型企业会让 IT 开发者和平民开发者使用四个以上的低代码开发工具。低代码开发工具的大船已经开始启航，大家在生活或是工作中要学习拥抱变化并保持开放的心态去接触更加多样的新技术新知识，才能够持续提高自身的竞争力和生产力。下面帮大家推荐三个不同类型的低代码工具和潜在的应用场景。\nAirtable - 最方便的云上数据库我相信大部分的读者看到数据库三个字就直接劝退了，Airtable 就是要改变过去的这种窘境，让非技术人员也能够轻易的创建云端数据库、定义数据存放目录、处理数据甚至是做到对接 API。大型公司应该都已经有自己的数据库且有很严谨的资产安全规范。Airtable 并一定适合作为公司内部系统的数据库，但是有其他场景或许可以成为个人提效工具。举一个例子给大家参考，我认识以为做投资的同事，平时会接触非常多的创业公司和投资者，因此需要一个小型的数据库可以存放个人&#x2F;公司资料以及使用不同类型标签来建立数据库数据之间的关联性。没有技术背景的他也能够在短时间内熟悉 Airtable 的操作并且打造出一个令主管赞誉有加的 CRM 云端数据库。\nZapier - 自动化小帮手Zapier 是一套工作流自动化工具，能够将市面上常见的、被广泛运用的应用程序进行连接，让不同的系统能够彼此沟通。Zapier 目前支持的应用程序已经超过 2000 个，最方便的地方是使用者能够直接在网站上找到已经创建好的、最受欢迎的自动化流程，不需要自己再花大把时间重新开发一个新的流程。官网上就有一个样例是当你在社交软件 A 发表文章的时候，可以同时在社交软件 B 上发文章，当这个 Zap （自动化流程简称）被设置好之后，未来你只需要在一个地方发布文章，所有其他的社交平台也都能够自动完成。同样的概念可以被运用在邮件、日程、待办事项、团队协作等，大家可以去发掘或者是创建自己喜欢的 Zap！\nRetool - 快速创建企业级应用系统Retool 是由一位年仅 25 岁的工程师在 2017 年创立的低代码开发平台，公司估值已经来到了 10 亿美金，目前公司的客户包括 Amazon、Mercedes Benz、Progressive、Gojek、Peloton、Rakuten 等。Retool 声称器服务运用了拖拽式的组件和轻量级的编程语言就可以让开发人员在开发应用上提高 40 倍的效率。Retool 的平台对于没有技术背景的人来说有一定的挑战性，但是相比较于过去的复杂开发环境、不友好的系统对接、不同系统的组件都需要重新开发的困境，开发的门槛已经是大幅降低了。\n结语我深刻的记得，我在美国读研的时候，当时有一位同事在美国一事业单位工作，他身边的同事都还在用计算器去做日常报表的数据处理。当他协助使用 Excel Macro 将所有的流程自动化后，他花了两个月时间自动化的报表可以取代 8 个人的全职工作，他也因此在两年之内就被提拔为单位组长。虽然这个故事对于熟练使用 Excel 的我们来说并没有感觉，但是在数字化发展迅速的今天，我们会不会很快的也被新一代的技术或是时代给淘汰。我深信在不远的将来，开发和实战能力会是所有企业最为需要的核心实力之一。平民开发者的时代即将来临！\n","slug":"citizen-developer","date":"2022-08-06T10:42:25.000Z","categories_index":"article","tags_index":"development,servicenow","author_index":"Zhongkang Shen"},{"id":"7a53aa4fac964f30959b1f35f2f8783c","title":"开发环境配置 Node","content":"\n安装 nvm 方便 Node 版本管理，可以在多版本 Node 之间切换curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash\n\n查看是否自动添加成功全局环境配置nvm ls\n\n安装一个版本的 Node 以 Node v14.x 最新版本为例nvm install 14.19.0\n\n如果系统中没有安装过 nvm 和 node 此时新安装的 Node 会变成默认使用的 Node# 查看 Node 版本\nnode -v\n\n# 查看 npm 版本\nnpm -v\n\n如果涉及拉取私服的 npm 包推荐安装 nrm，用来做 npm registry 源管理，安装命令是 npm i -g nrm，可以在公司二方库的源和公网 npm 源之间切换，方便安装私服的 npm 包。\n配置私服源# 在 nrm 中增加 registry\nnrm add mycompany http://npm.mycompany.com/repository/npm/\n\n# 使用新增的源\nnrm use mycompany\n","slug":"node-env-config","date":"2022-03-02T03:36:58.000Z","categories_index":"node,frontend","tags_index":"development,node","author_index":"Zhongkang Shen"},{"id":"b6042d1b6a77b8a731962e66d98b63e3","title":"短链接 - ShortURL","content":"What？是一种互联网上的技术与服务，此服务可以提供短 URL 来替代原来可能较长的 URL，将长的 URL 地址缩短。用户访问缩短后的 URL 时，通常将会重定向到原来的 URL。\nWhy？\n长链接不美观。\n许多 web 开发者通过网址传输描述属性（如：表示数据的结构层次，命令结构，交易路径[transiaction paths]以及会话[session]信息），这造成了 URL 过长、形式复杂，难以记忆。\n某些社交平台或 BBS 等，类似于 twitter 对于每条帖子或消息有字数限制（多为 140 字），因此需要通过缩短网址的功能来达到缩短分享链接的目的。\n便于记忆，可以自定义。\n当网址编译成二维码时，可减少二维码的面积，通过降低二维码的密度从而提高可靠性。\n\nHow?\nHash（长网址为哈希键，短网址为哈希值）\n主键自增 id 索引（id 为短网址的路径，如：www.xxxx.com/id/1, 另一个字段用于存储长网址）\n\nAdvantage\n简洁且准确。\n方便引流，从而提升品牌知名度和用户信任。\n社交网址防止被屏蔽或跟踪。\n\nDisadvantage\n由于短链接具有隐匿原始地址的特性，用户无法通过短网址的“外观”得知真实地址。近些年，短链接已经成为骗子和垃圾邮件发送者的工具。\n甚至重定向到已被列入黑名单的 URL 地址。\n另一个潜在缺点是，如果 URL 缩短服务器关闭，那么链接将不再重定向到正确的位置。导致 linkrot 现象。\n\nAbout部分短链接会在目标 URL 之前生成一个重定向页，并在页面放置广告以获取利润。\n当访客点入短网址后，必须要在充满广告的页面内点击特定按钮才能抵达目的地。这类型网页通常会造成访客的不快。因此需要搭配分润机制来吸引流量提供商使用这样的缩短网址。\nLinksTiny\n","slug":"short-url","date":"2022-02-25T06:34:11.000Z","categories_index":"tutorial,article","tags_index":"shorturl,url","author_index":"Zhongkang Shen"},{"id":"194d81d78289ca046c5db02cd53b6d7d","title":"Nginx CORS Configuration","content":"location / &#123;\n\t# root /usr/share/nginx/html;\n\t# index index.html index.htm;\n\tif ($request_method = 'OPTIONS') &#123;\n\t\tadd_header 'Access-Control-Allow-Origin' '*' always;\n\t\tadd_header 'Access-Control-Allow-Credentials' 'true';\n\t\tadd_header 'Access-Control-Allow-Methods' 'GET, POST, PATCH, DELETE, PUT, OPTIONS';\n\t\tadd_header 'Access-Control-Allow-Headers' 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Access-Control-Expose-Headers,Token,Authorization,X-WEBAUTH-USER';\n\t\tadd_header 'Access-Control-Max-Age' 1728000;\n\t\tadd_header 'Content-Type' 'text/plain charset=UTF-8';\n\t\tadd_header 'Content-Length' 0;\n\t\treturn 204;\n\t&#125;\n\tadd_header 'Access-Control-Allow-Headers' 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Access-Control-Expose-Headers,Token,Authorization,X-WEBAUTH-USER';\n\tadd_header 'Access_Control-Allow-Origin' '*' always;\n\tproxy_pass http://localhost:3000;\n&#125;\n","slug":"nginx-cors","date":"2021-11-25T07:32:15.000Z","categories_index":"nginx","tags_index":"nginx,cors","author_index":"Zhongkang Shen"},{"id":"b7c9b3bcfbf4e44b360ea8bb1c1b66f8","title":"How to build a code editor with codemirror v6","content":"Codemirror （以下简称 CM） 即将到来的新版本 CM 6，已经在其官网顶部 sticky bar 上加入了宣传链接，CM 6 是一次大的重写，并且在性能和解析等其他方面，都有极大的提升（Much-improved rewrite）。CM 6 采用了 scope 形式的 npm 包，将配置、视图、状态、扩展、语言支持等分为了单独的 npm 包，这样做的好处不言而喻了，相比起费尽心思的去配置 tree-shaking，这种与生俱来的可配置性，使用 slot 的做法，不仅可扩展性提高了，而且对于打包体积也更加的可控。\n在写这篇的时候，我正在启动一个新的项目（Glide-web），该项目是一个数据模型驱动低代码平台。其中有一个用到 CM 的模块，叫做 ”Script Include“ ，用以在前端 UI 上以编码的形式，来操作逻辑表和表单域。当前系统设计里，允许用户编写的代码语言为 Groovy，但按照 ServiceNow 的原型，这里应该会是使用 JavaScript 来编写脚本，利用中台的 Node 中间件来执行，也许前期先做了简单的实现吧。\n在这个模块中，我就使用了 CM 6 来构建了 Code Editor，下面就记录下我的开发过程。\n首先要吐槽的是 CM 6 官方的网站是有了，但是文档写的是真的不行，只是告诉了开发者，CM 6 能够完成哪些事情、实现什么功能、多么强大多么好之类的，但是没有一个入手指南，只给出了单个模块的 interface 介绍，看的着实很费劲，也有可能是还没有做好吧。\noooook，下面开始进入正题。\nSetup首先肯定是要有个项目（废话！！）。CM 6 里面用于构建 UI 的 @codemirror&#x2F;view 和用于状态管理的 @codemirror&#x2F;state 都是拆分开来的，不过正经人开发时候，一般都会结合这两个使用，所以需要首先安装这两个包，哎，不过，CM 6 也考虑到大部分人的使用场景，额外的提供了一个包 @codemirror&#x2F;basic-setup 这个包，就是对于上面两个包的合并导出，这样，开发者就可以从一个包里导出 view 和 state 两个模块了，是不是合理多了？\nnpm i @codemirror/basic-setup\n然后在我们的代码里引入\nimport &#123; EditorView, EditorState, basicSetup &#125; from '@codemirror/basic-setup';\n\n...\nconst editor = new EditorView(&#123;\n\tstate: EditorState.create(&#123;\n\t\textensions: [ basicSetup ]\n\t&#125;),\n\tparent: document.body\n&#125;);\n...\n\n上面这段代码，返回的是 View 对象。state 接收一个 EditorState 对象用来管理一系列的包含内容、位置等状态信息以及对这些上下文的操作函数。parent 就是编辑器想要挂载的 DOM 对象，在 React 中我们通常会使用 ref.current 来指定具体的某个 DOM 元素。\n按照上面最基本的写法，就能实现个编辑器了，不过真就是最基本的，啥也不是。所以，下面说下进阶的配置。\nLanguage最重要的肯定是希望提供语法高亮支持啦。CM 6 使用的语言支持，也是以单个包的形式引入的，在写这边文档的时候，CM 6 支持的语言还不足 10 种，与 CM 5 支持的 100 多种语言相比，仍然还有很长的路要走，CM 6 允许使用三种方式来编写自己的语法解析器，Lezer、steam-parser、完全自定义的解析器。CM 6 首推的是用 lezer 来做语法解析生成器。\n下面用 JavaScript 来举例。首先你需要安装 @codemirror/lang-javascript ，CM 6 推荐开发者编写的语言解析包，都要以 @codemirror/lang-example 这种格式的命名，好让包能够见名知意。\nimport &#123; javascript &#125; from '@codemirror/lang-javascript';\n\n...\nconst editor = new EditorView(&#123;\n\tstate: EditorState.create(&#123;\n\t\textensions: [basicSetup, javascript()]\n\t&#125;),\n\tparent: document.body\n&#125;);\n...\n\nDocument代码内容的初始化，在配置的 doc 字段中配置。\nconst editor = new EditorView(&#123;\n  state: EditorState.create(&#123;\n    extensions: [basicSetup, javascript()],\n    doc: `console.log(1);`,\n  &#125;),\n  parent: document.body,\n&#125;);\n\n那如何读写 Editor 的内容呢？首先是读取：\nconst currentValue = editor.state.doc.toString(); // `console.log(1);`\n\n写入内容需要注意了，不能直接更改这个 State 配置中的 doc，这个是配置，是用来初始化的，除非你整个编辑器重新初始化的同时去修改 doc。修改内容 CM 6 采用了 dispatch 的形式，更符合数据流状态管理的设计原则。\neditor.dispatch(&#123;\n  changes: &#123;\n    from: 0, // 从起始位置\n    insert: 'abc', // 插入字符 \"abc\"\n  &#125;,\n&#125;);\n\n经过上面的操作，我们得到的新的文本就变成了 abcconsole.log(1); 显然，大部分情况下， 我们不使用这种插入的方式，除非是在文后追加代码。常用的还是替换，或者说更改全部的内容。\nconst currentValue = editor.state.doc.toString();\nconst endPosition = currentValue.length;\n\neditor.dispatch(&#123;\n  changes: &#123;\n    from: 0,\n    to: endPosition,\n    insert: 'something else',\n  &#125;,\n&#125;);\n\nListen for Changes监听编辑器内容变化也是常用的功能之一。需要监听，我们要在配置 extensions 中增加 updateListener 。\nimport &#123; EditorState, EditorView, basicSetup &#125; from '@codemirror/basic-setup';\nimport &#123; html &#125; from '@codemirror/lang-html';\n\nlet editor = new EditorView(&#123;\n  state: EditorState.create(&#123;\n    extensions: [\n      basicSetup,\n      html(),\n      EditorView.updateListener.of((v) => &#123;\n        if (v.docChanged) &#123;\n          console.log('DO SOMETHING WITH THE NEW CODE');\n        &#125;\n      &#125;),\n    ],\n  &#125;),\n  parent: document.body,\n&#125;);\n\n这里如果要考虑性能问题，需要加个节流。\nimport &#123; EditorState, EditorView, basicSetup &#125; from '@codemirror/basic-setup';\nimport &#123; html &#125; from '@codemirror/lang-html';\n\nlet timer;\n\nlet editor = new EditorView(&#123;\n  state: EditorState.create(&#123;\n    extensions: [\n      basicSetup,\n      html(),\n      EditorView.updateListener.of((v) => &#123;\n        if (v.docChanged) &#123;\n          if (timer) clearTimeout(timer);\n          timer = setTimeout(() => &#123;\n            console.log('DO SOMETHING WITH THE NEW CODE');\n          &#125;, 500);\n        &#125;\n      &#125;),\n    ],\n  &#125;),\n  parent: document.body,\n&#125;);\n\nTheme目前可用的官方主题，除了默认的就只有一个 one-dark 的 theme，包名是 @codemirror/theme-one-dark ，在扩展中配置主题。\nimport &#123; oneDarkTheme &#125; from '@codemirror/theme-one-dark';\n\n...\nconst editor = new EditorView(&#123;\n\tstate: EditorState.create(&#123;\n\t\textensions: [\n\t\t\tbasicSetup,\n\t\t\tjavascript(),\n\t\t\toneDarkTheme\n\t\t]\n\t&#125;),\n\tparent: document.body\n&#125;);\n...\n\n可用的主题少的另外一个原因，CM 6 是非常容易定制化一个个性的主题的，采用了 CSS-in-JS 的写法。\nconst yourTheme = EditorView.theme(\n  &#123;\n    '&amp;': &#123;\n      color: 'white',\n      backgroundColor: '#034',\n    &#125;,\n    '.cm-content': &#123;\n      caretColor: '#0e9',\n    &#125;,\n    '&amp;.cm-focused .cm-cursor': &#123;\n      borderLeftColor: '#0e9',\n    &#125;,\n    '&amp;.cm-focused .cm-selectionBackground, ::selection': &#123;\n      backgroundColor: '#074',\n    &#125;,\n    '.cm-gutters': &#123;\n      backgroundColor: '#045',\n      color: '#ddd',\n      border: 'none',\n    &#125;,\n  &#125;,\n  &#123; dark: true &#125;\n);\n\n如果你仅仅是想在现有的主题上进行少部分的修改，也是可以的。\n// 在默认主题基础上修改\nimport &#123; EditorView &#125; from '@codemirror/view';\n\nconst myTheme = EditorView.baseTheme(&#123;\n  '&amp;.cm-editor': &#123;\n    fontSize: '16px',\n  &#125;,\n  '.cm-scroller': &#123;\n    fontFamily:\n      'Consolas, Menlo, Monaco, source-code-pro, Courier New, monospace',\n  &#125;,\n&#125;);\n","slug":"codemirror6","date":"2021-10-27T03:58:53.000Z","categories_index":"frontend,react","tags_index":"frontend,react,codemirror","author_index":"Zhongkang Shen"},{"id":"bc28920ac9662d7c26811a532ee24d7f","title":"Code Differ","content":"前置依赖（除 codemirror 外）：\n\nmerge.min.js 和 merge.min.css\ndiff_match_path.js\n\ndiff/index.js\n/**\n * config compare\n */\nimport React, &#123; useState, useEffect, Fragment &#125; from 'react';\nimport Layout from 'components/Layout';\nimport &#123; Row, Select, notification &#125; from 'antd';\nimport &#123; get &#125; from 'common/xFetch2';\nimport DiffView from './diff-view';\nimport styles from './styles.less';\n\nconst &#123; Option &#125; = Select;\n\nconst ConfigDiff = (&#123; location = &#123;&#125; &#125;) => &#123;\n  const &#123; record = &#123;&#125; &#125; = location.state;\n\n  const [loading, setLoading] = useState(false);\n  const [versions, setVersions] = useState([]);\n  const [diffCountArray, setDiffCountArray] = useState([]);\n  const [sourceVersion, setSourceVersion] = useState();\n  const [targetVersion, setTargetVersion] = useState();\n  const [sourceMeta, setSourceMeta] = useState();\n  const [targetMeta, setTargetMeta] = useState();\n  const [sourceMap, setSourceMap] = useState(&#123;&#125;); // source text mapping\n  const [targetMap, setTargetMap] = useState(&#123;&#125;); // target text mapping\n\n  // get all versions when page loaded.\n  useEffect(() => &#123;\n    getVersions();\n  &#125;, []);\n\n  // fetch source version data when source version changed.\n  useEffect(() => &#123;\n    if (sourceVersion) &#123;\n      getSourceMeta();\n    &#125;\n  &#125;, [sourceVersion]);\n\n  // fetch target version data when target version changed.\n  useEffect(() => &#123;\n    if (targetVersion) &#123;\n      getTargetMeta();\n    &#125;\n  &#125;, [targetVersion]);\n\n  // organize source &amp; target mapping data when meta data changed.\n  useEffect(() => &#123;\n    if (sourceMeta &amp;&amp; targetMeta) &#123;\n      const &#123; content: srcContent = [] &#125; = sourceMeta;\n      const &#123; content: tarContent = [] &#125; = targetMeta;\n      const srcPathSet = new Set(srcContent.map((conf) => conf.path));\n      const tarPathSet = new Set(tarContent.map((conf) => conf.path));\n      const finalPathSet = new Set([...srcPathSet, ...tarPathSet]);\n      const srcMapping = &#123;&#125;;\n      const tarMapping = &#123;&#125;;\n      srcContent.forEach((conf) => &#123;\n        srcMapping[conf.path] = conf;\n      &#125;);\n      tarContent.forEach((conf) => &#123;\n        tarMapping[conf.path] = conf;\n      &#125;);\n      setSourceMap(srcMapping);\n      setTargetMap(tarMapping);\n      setDiffCountArray(Array.from(finalPathSet));\n    &#125;\n  &#125;, [sourceMeta, targetMeta]);\n\n  // fetch all versions.\n  const getVersions = async () => &#123;\n    setLoading(true);\n    const res = await get(\n      `/api/auto/v1/auto-app-components-record/versions?component_id=$&#123;record.id&#125;`\n    );\n    setLoading(false);\n    if (res.status !== 'success') &#123;\n      return notification.error(&#123; message: res.message &#125;);\n    &#125;\n    const &#123; list = [] &#125; = res.content;\n    setVersions(list);\n  &#125;;\n\n  // fetch source meta data.\n  const getSourceMeta = async () => &#123;\n    setLoading(true);\n    const res = await get(\n      `/api/auto/v1/auto-app-components-record?version=$&#123;sourceVersion&#125;`\n    );\n    setLoading(false);\n    if (res.status !== 'success') &#123;\n      return notification.error(&#123; message: res.message &#125;);\n    &#125;\n    const &#123; content = &#123; content: [] &#125; &#125; = res;\n    setSourceMeta(content);\n  &#125;;\n\n  // fetch target meta data.\n  const getTargetMeta = async () => &#123;\n    setLoading(true);\n    const res = await get(\n      `/api/auto/v1/auto-app-components-record?version=$&#123;targetVersion&#125;`\n    );\n    setLoading(false);\n    if (res.status !== 'success') &#123;\n      return notification.error(&#123; message: res.message &#125;);\n    &#125;\n    const &#123; content = &#123; content: [] &#125; &#125; = res;\n    setTargetMeta(content);\n  &#125;;\n\n  return (\n    &lt;Layout title=&#123;`版本比较（$&#123;record.name&#125;）`&#125; goBack=&#123;true&#125;>\n      &lt;div className=&#123;styles.compareHeader&#125;>\n        &lt;div className=&#123;styles.compareTitle&#125;>\n          &lt;Select\n            showSearch=&#123;true&#125;\n            style=&#123;&#123; width: 350 &#125;&#125;\n            placeholder='请选择版本'\n            onSelect=&#123;(v) => setSourceVersion(v)&#125;\n            loading=&#123;loading&#125;\n          >\n            &#123;versions.map((v) => (\n              &lt;Option key=&#123;v&#125; value=&#123;v&#125;>\n                &#123;v&#125;\n              &lt;/Option>\n            ))&#125;\n          &lt;/Select>\n          &#123;sourceMeta ? (\n            &lt;p>&#123;`$&#123;sourceMeta.creator&#125; 于 $&#123;sourceMeta.created_at&#125; 修改`&#125;&lt;/p>\n          ) : (\n            &lt;p>请选择版本以查看信息&lt;/p>\n          )&#125;\n        &lt;/div>\n        &lt;div className=&#123;styles.headerGap&#125;>版本号&lt;/div>\n        &lt;div className=&#123;styles.compareTitle&#125;>\n          &lt;Select\n            showSearch=&#123;true&#125;\n            style=&#123;&#123; width: 350 &#125;&#125;\n            placeholder='请选择版本'\n            onSelect=&#123;(v) => setTargetVersion(v)&#125;\n            loading=&#123;loading&#125;\n          >\n            &#123;versions.map((v) => (\n              &lt;Option key=&#123;v&#125; value=&#123;v&#125;>\n                &#123;v&#125;\n              &lt;/Option>\n            ))&#125;\n          &lt;/Select>\n          &#123;targetMeta ? (\n            &lt;p>&#123;`$&#123;targetMeta.creator&#125; 于 $&#123;targetMeta.created_at&#125; 修改`&#125;&lt;/p>\n          ) : (\n            &lt;p>选择版本以查看信息&lt;/p>\n          )&#125;\n        &lt;/div>\n      &lt;/div>\n      &lt;Row className=&#123;styles.diffContainer&#125;>\n        &#123;sourceMeta &amp;&amp; targetMeta ? (\n          &lt;div>\n            &#123;diffCountArray.map((path, index) => &#123;\n              return (\n                &lt;Fragment>\n                  &lt;div className=&#123;styles.confTitle&#125;>&#123;`配置路径: $&#123;path&#125;`&#125;&lt;/div>\n                  &lt;DiffView\n                    key=&#123;`$&#123;path&#125;-$&#123;index&#125;`&#125;\n                    sourceText=&#123;sourceMap[path] &amp;&amp; sourceMap[path].content&#125;\n                    targetText=&#123;targetMap[path] &amp;&amp; targetMap[path].content&#125;\n                  />\n                &lt;/Fragment>\n              );\n            &#125;)&#125;\n            &lt;div className=&#123;styles.confTitle&#125;>&#123;`发布模板`&#125;&lt;/div>\n            &lt;DiffView\n              sourceText=&#123;sourceMeta.deploy_tpl || ''&#125;\n              targetText=&#123;targetMeta.deploy_tpl || ''&#125;\n            />\n          &lt;/div>\n        ) : (\n          &lt;p>请选择两个版本进行比较&lt;/p>\n        )&#125;\n      &lt;/Row>\n    &lt;/Layout>\n  );\n&#125;;\n\nexport default ConfigDiff;\n\ndiff/styles.less\n.compareHeader &#123;\n  display: flex;\n  height: 100px;\n  border: 1px solid #c4cdd7aa;\n  background-color: #f6f7f8;\n  border-radius: 4px;\n  align-items: center;\n  .compareTitle &#123;\n    text-align: center;\n    flex: 1;\n    p &#123;\n      margin: 8px 0 0;\n      font-size: 12px;\n      color: #4c5a7188;\n    &#125;\n  &#125;\n  .headerGap &#123;\n    border: 2px solid #c4cdd7aa;\n    border-top: none;\n    border-bottom: none;\n    width: 110px;\n    height: 100%;\n    display: inline-flex;\n    align-items: center;\n    justify-content: center;\n    font-size: 18px;\n  &#125;\n&#125;\n\n.diffContainer &#123;\n  margin-top: 12px;\n  :global &#123;\n    .CodeMirror-merge &#123;\n      margin-bottom: 20px;\n      .CodeMirror &#123;\n        border-bottom: 1px solid #c4cdd7aa;\n      &#125;\n    &#125;\n  &#125;\n  .confTitle &#123;\n    text-align: center;\n    padding-bottom: 10px;\n  &#125;\n&#125;\n","slug":"code-differ-react","date":"2021-01-25T12:49:40.000Z","categories_index":"frontend,react","tags_index":"frontend,react,codemirror","author_index":"Zhongkang Shen"},{"id":"07a79f5d09140cc1a089be652513c5fe","title":"一些代码优化技巧","content":"1. 判断多个平行条件\n\n\n\n\n\n\n\n\n可以将参与判断的多个条件存为一个数组，使用数组的 includes 方法判断\n// longhand\nif (x === 'abc' || x === 'def' || x === 'ghi' || x === 'jkl') &#123;\n  /*** some code ***/\n&#125;\n\n// shorthand\nif (['abc', 'def', 'ghi', 'jkl'].includes(x)) &#123;\n  /*** some code ***/\n&#125;\n\n2. 简单的 if ... else\n\n\n\n\n\n\n\n\n对于不包含大量逻辑代码的判断，可以使用三元来判断。\n// longhand\nvar test: boolean;\n\nif (x > 100) &#123;\n  test = true;\n&#125; else &#123;\n  test = false;\n&#125;\n\n// shorthand\nvar test = x > 100 ? true : false;\n\nconsole.log(test);\n\n当有嵌套的条件时:\nvar x = 300,\n  test2 =\n    x > 100\n      ? 'greater than 100'\n      : x &lt; 50\n      ? 'less than 50'\n      : 'between 50 and 100';\n\nconsole.log(test2); // 'greater than 100'\n\n3. 声明变量\n\n\n\n\n\n\n\n\n当声明多个具有普通类型和普通值的变量时\n// longhand\nlet test1 = 1;\nlet test2 = 1;\n\n// shorthand\nlet test1,\n  test2 = 1;\n\n// longhand\nlet test1: boolean;\nlet test2: boolean;\n\n// shorthand\nlet test1, test2: boolean;\n\n4. null, undefined和空值判断// longhand\nif (test1 !== null || test1 !== undefined || test1 !== '') &#123;\n  var test2 = test1;\n&#125;\n\n// shorthand\nvar test2 = test1 || '';\n\n5. null 检查并赋默认值var test1 = null,\n  test2 = test1 || '';\n\nconsole.log('null check', test2); // output: '' (an empty string)\n\n6. undefined 检查并赋默认值var test1 = undefined,\n  test2 = test1 || '';\n\nconsole.log('undefined check', test2); // output: '' (an empty string)\n\n7. 多个变量赋值// longhand\nlet test1, test2, test3;\ntest1 = 1;\ntest2 = 2;\ntest3 = 3;\n\n// shorthand\nlet [test1, test2, test3] = [1, 2, 3];\n\n8. 运算符简化// longhand\ntest1 = test1 + 1;\ntest2 = test2 - 1;\ntest3 = test3 * 10;\n\n// shorthand\ntest1++;\ntest2--;\ntest3 * = 10;\n\n9. 真值判断\n\n\n\n\n\n\n\n\n虽然平时常用，但仍值得一提\n// longhand\nif (test1 === true) &#123;\n&#125;\n\n// shorthand\nif (test1) &#123;\n&#125;\n\n相反的判断:\n// longhand\nvar test1;\nif (test1 !== true) &#123;\n  // do something\n&#125;\n\n// shorthand\nvar test1;\nif (!test1) &#123;\n  // do something\n&#125;\n\n10. AND(&amp;&amp;) 操作符判断条件\n\n\n\n\n\n\n\n\n如果只在条件为真时才调用函数\n// longhand\nif (test1) &#123;\n  callMethod();\n&#125;\n\n// shorthand\ntest1 &amp;&amp; callMethod();\n\n11. foreach 循环// longhand\nfor (var i = 0; i &lt; testData.length; i++)\n\n// shorthand\nfor (var i in testData)\n\nfunction testData(element, index, array) &#123;\n  console.log('test[' + index + '] = ' + element);\n&#125;\n\n[1, 2, 3].forEach(testData);\n// logs: test[0] = 1, test[1] = 2, test[2] = 3\n\n12. 条件判断返回// longhand\nif (!(test == undefined)) &#123;\n  return test;\n&#125; else &#123;\n  return callMe('test');\n&#125;\n\n// shorthand\nreturn ret || callMe('test');\n\n13. 箭头函数// longhand\nfunction add(test1, test2) &#123;\n  return test1 + test2;\n&#125;\n\n// shorthand\nconst add = (test1, test2) => test1 + test2;\n\nfunction callMe(name) &#123;\n  console.log('Hello', name);\n&#125;\n\ncallMe = (name) => console.log('Hello', name);\n\n14. 缩短函数调用\n\n\n\n\n\n\n\n\n使用三元运算符\n// longhand\nfunction test1() &#123;\n  console.log('test1');\n&#125;\n\nfunction test2() &#123;\n  console.log('test2');\n&#125;\n\nvar test3 = 1;\nif (test3 == 1) &#123;\n  test1();\n&#125; else &#123;\n  test2();\n&#125;\n\n// shorthand\n(test3 === 1 ? test1 : test2)();\n\n15. switch 函数调用// longhand\nswitch (data) &#123;\n  case 1:\n    test1();\n    break;\n  case 2:\n    test2();\n    break;\n  case 3:\n    test();\n    break;\n  // And so on ...\n&#125;\n\n// shorthand\nvar data = &#123;\n  1: test1,\n  2: test2,\n  3: test,\n&#125;;\n\ndata[something] &amp;&amp; data[something]();\n\n16. 隐式返回\n\n\n\n\n\n\n\n\n使用箭头函数特性\n// longhand\nfunction calcCircumference(diameter) &#123;\n  return Math.PI * diameter;\n&#125;\n\n// shorthand\ncalcCircumference = (diameter) => Math.PI * diameter;\n\n17. 科学计数// longhand\nfor (var i = 0; i &lt; 10000; i++) &#123; ... &#125;\n\n// shorthand\nfor (var i = 0; i &lt; 1e4; i++) &#123; ... &#125;\n\n18. 参数默认值// longhand\nfunction add(test1, test2) &#123;\n  if (test1 === undefined) test1 = 1;\n  if (test2 === undefined) test2 = 2;\n  return test1 + test2;\n&#125;\n\n// shorthand\nadd = (test1 = 1, test2 = 2) => test1 + test2;\n\nadd(); // output: 3\n\n19. 对象扩展符// longhand\nconst data = [1, 2, 3];\nconst test = [4, 5, 6].concat(data);\n\n// shorthand\nconst data = [1, 2, 3];\nconst test = [4, 5, 6, ...data];\nconsole.log(test); // [4, 5, 6, 1, 2, 3];\n\n拷贝\n// longhand\nconst test1 = [1, 2, 3];\nconst test2 = test1.slice();\n\n// shorthand\nconst test1 = [1, 2, 3];\nconst test2 = [...test1];\n\n20. 模板字符串// longhand\nconst welcome = 'Hi ' + test1 + ' ' + test2 + '.';\n\n// shorthand\nconst welcome = `Hi $&#123;test1&#125; $&#123;test2&#125;`;\n\n21. 多行字符串// longhand\nconst lorem =\n  'Lorem ipsum dolor sit amet, consectetur\\n\\t' +\n  'adipisicing elit, sed do eiusmod tempor incididunt\\n\\t' +\n  'ut labore et dolore magna aliqua. Ut enim ad minim\\n\\t' +\n  'veniam, quis nostrud exercitation ullamco laboris\\n\\t' +\n  'nisi ut aliquip ex ea commodo consequat. Duis aute\\n\\t' +\n  'irure dolor in reprehenderit in voluptate velit esse.\\n\\t';\n\n//shorthand\nconst lorem = `Lorem ipsum dolor sit amet, consectetur\n    adipisicing elit, sed do eiusmod tempor incididunt\n    ut labore et dolore magna aliqua. Ut enim ad minim\n    veniam, quis nostrud exercitation ullamco laboris\n    nisi ut aliquip ex ea commodo consequat. Duis aute\n    irure dolor in reprehenderit in voluptate velit esse.`;\n\n22. 对象属性简写let test1 = 'a';\nlet test2 = 'b';\n\n// longhand\nlet obj = &#123; test1: test1, test2: test2 &#125;;\n\n// shorthand\nlet obj = &#123; test1, test2 &#125;;\n\n23. 字符串转数字// longhand\nlet test1 = parseInt('123');\nlet test2 = parseFloat('12.3');\n\n// shorthand\nlet test1 = +'123';\nlet test2 = +'12.3';\n\n24. 解构// longhand\nconst test1 = this.data.test1;\nconst test2 = this.data.test2;\nconst test3 = this.data.test3;\n\n// shorthand\nconst &#123; test1, test2, test3 &#125; = this.data;\n\n25. Array.findconst data = [\n  &#123; type: 'test1', name: 'abc' &#125;,\n  &#123; type: 'test2', name: 'def' &#125;,\n  &#123; type: 'test1', name: 'ghi' &#125;,\n];\n\nfunction findtest1(name) &#123;\n  for (let i = 0; i &lt; data.length; ++i) &#123;\n    if (data[i].type === 'test1' &amp;&amp; data[i].name === name) &#123;\n      return data[i];\n    &#125;\n  &#125;\n&#125;\n\n// shorthand\nfilteredData = data.find(\n  (data) => data.type === 'test1' &amp;&amp; data.name === 'fgh'\n);\nconsole.log(filteredData); // &#123; type: 'test1', name: 'ghi' &#125;\n\n26. 检索条件// longhand\nif (type === 'test1') &#123;\n  test1();\n&#125; else if (type === 'test2') &#123;\n  test2();\n&#125; else if (type === 'test3') &#123;\n  test3();\n&#125; else if (type === 'test4') &#123;\n  test4();\n&#125; else &#123;\n  throw new Error('Invalid value ' + type);\n&#125;\n\n// shorthand\nvar types = &#123;\n  test1: test1,\n  test2: test2,\n  test3: test3,\n  test4: test4,\n&#125;;\n\nvar func = types[type];\n!func &amp;&amp; throw new Error('Invalid value ' + type);\nfunc();\n\n27. 按位索引\n\n\n\n\n\n\n\n\nThe bitwise(~) operator will return a truthy value for anything but -1. Negating it is as simple as doing !~.\n// longhand\nif (arr.indexOf(item) > -1) &#123;\n  // item found\n&#125;\n\nif (arr.indexOf(item) === -1) &#123;\n  // item not found\n&#125;\n\n// shorthand\nif (~arr.indexOf(item)) &#123;\n  // item found\n&#125;\n\nif (!~arr.indexOf(item)) &#123;\n  // item not found\n&#125;\n\n28. Object.entries()\n\n\n\n\n\n\n\n\n将对象转化为数组\nconst data = &#123; test1: 'abc', test2: 'cde', test3: 'efg' &#125;;\nconst arr = Object.entries(data);\nconsole.log(arr);\n\n/** Output:\n * [ ['test1', 'abc'],\n *   ['test2', 'cde'].\n *   ['test3', 'efg']\n * ]\n */\n\n29. Object.values()\n\n\n\n\n\n\n\n\n[ES8] 类似 Object.entries(), 不含 key\nconst data = &#123; test1: 'abc', test2: 'cde' &#125;;\nconst arr = Object.values(data);\nconsole.log(arr);\n\n/** Output:\n * [ 'abc', 'cde' ]\n * /\n\n30. 双按位非运算 ~~\n\n\n\n\n\n\n\n\n!~~ 仅适用于 32 位整型\n// longhand\nMath.floor(1.9) === 1; // true\n\n// shorthand\n~~1.9 === 1; // true\n\n31. 重复字符串// longhand\nlet test = '';\nfor (let i = 0; i &lt; 5; i++) &#123;\n  test += 'test ';\n&#125;\nconsole.log(test); // test test test test test\n\n// shorthand\n'test '.repeat(5);\n\n32. 数组中最大最小值const arr = [1, 2, 3];\nMath.max(...arr); // 3\nMath.min(...arr); // 1\n\n33. 字符串中的某个字符let str = 'abc';\n// longhand\nstr.charAt(2); // c\n\n// shorthand\nstr[2]; // c\n\n34. 次方// longhand\nMath.pow(2, 3); // 8\n\n// shorthand\n2 ** 3; // 8\n","slug":"javascript-34-shorthands","date":"2021-01-05T06:42:57.000Z","categories_index":"frontend,tips","tags_index":"frontend,code","author_index":"Zhongkang Shen"},{"id":"2a5b9e073fe829313e9670bd00f2af01","title":"如何优雅地展开(拍平)一个数组","content":"问题给定任一数组xs，其内部可能包含任意类型的值或是其他数组。我们希望展开xs内部所有的值，变为一个一维数组。例如：\n\nflatten([1, [3], [[6, 7], [[[]], 8]]]) =&gt; [1, 3, 6, 7, 8]\nflatten([&#123;a: 3&#125;, 1, [[&#39;&#39;], 2]]) =&gt; [&#123;a: 3&#125;, 1, &#39;&#39;, 2]\n\n递归方案当我们要实现一个递归的方案时，我们必须避免递归地去思考。不要让你的代码陷入到递归调用里。正确的方法是假设你的函数能够在一个输入一个较小的数组时正常工作，在这种情况下，较小的输入结构显然是xs的尾部，即xs.slice(1)。这种假设称为信仰之跃。\n那么，当flatten(xs.slice(1))能够正确输出时，我们怎么样来完成整个的flatten(xs)呢？显然我们还缺少xs[0],xs[0]可能是一个非数组，也有可能是一个数组。\n如果xs[0]是个非数组，那处理起来就很简单，我们直接给他加到数组的第一个位置就行。\n如果xs[0]是个数组呢，那我们就继续信仰之跃，然后递归的调用flatten(xs[0]),把结果合并起来就好。\nfunction flatten(xs) &#123;\n  if (Array.isArray(xs[0])) return [...flatten(xs[0]), ...flatten(xs.slice(1))];\n  else return [xs[0], ...flatten(xs.slice(1))];\n&#125;\n\n至此，基本算是完成了。不过我们还忽略了最简单的输入，如果输入的是个空数组呢？我们应该直接返回空数组。\n所以，最终代码如下：\nfunction flatten(xs) &#123;\n  if (xs.length === 0) return [];\n  if (Array.isArray(xs[0])) return [...flatten(xs[0]), ...flatten(xs.slice(1))];\n  else return [xs[0], ...flatten(xs.slice(1))];\n&#125;\n","slug":"elegantly-flatten-a-list","date":"2020-12-18T03:17:20.000Z","categories_index":"frontend,javascript","tags_index":"frontend,javascript","author_index":"Zhongkang Shen"},{"id":"d6857a020c2a18887ebb33b9a47ceff4","title":"Code Editor","content":"Code Editor\nCodemirror想要在 react 中使用 codemirror，有两种主要的方式，一种是直接使用 codemirror 这个包，另外一种是使用 codemirror 作为语法和样式库，然后另外使用开发者自行封装的 react 受控或非受控组件。\n\n仅使用 codemirror\n通过 npm i codemirror 安装 codemirror\n// App.js\nimport &#123; useState, useRef, useEffect &#125; from 'react';\nimport CM from 'codemirror'; // 导入codemirror库\nimport 'codemirror/lib/codemirror.css'; // 导入codemirror样式\nimport 'codemirror/theme/material.css'; // 导入codemirror material主题\nimport 'codemirror/mode/xml/xml'; // 导入xml语言支持，html也用xml就行\nimport './styles.css';\n\nconst App = () => &#123;\n  const editor = useRef(null);\n  const [content] = useState(`\n    &lt;h1>Hello world&lt;/h1>\n    &lt;h1>你好，世界&lt;/h1>\n  `);\n\n  useEffect(() => &#123;\n    editor.current = CM.fromTextArea(editor.current, &#123;\n      lineNumbers: true,\n      lineWrapping: true,\n      theme: 'material',\n      mode: 'xml',\n      lint: true,\n    &#125;);\n\n    editor.current.setValue(content);\n  &#125;, [content]);\n\n  return (\n    &lt;div className='App'>\n      &lt;textarea ref=&#123;editor&#125; />\n    &lt;/div>\n  );\n&#125;;\n\nexport default App;\n\n\n使用 react-codemirror2 库，配合 codemirror 库使用\n\n首先还是要通过 npm 安装， npm i codemirror react-codemirror2\nimport &#123; useState &#125; from 'react';\nimport &#123; Controlled as ControlledEditor &#125; from 'react-codemirror2';\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/material.css';\nimport 'codemirror/mode/javascript/javascript';\n\nconst Editor = () => &#123;\n  const [content, setContent] = useState(`let a = 1;`);\n\n  return (\n    &lt;ControlledEditor\n      options=&#123;&#123;\n        theme: 'material',\n        mode: 'javascript',\n        lineNumbers: true,\n        lineWrapping: true,\n      &#125;&#125;\n      value=&#123;content&#125;\n      onBeforeChange=&#123;(editor, data, value) => setContent(value)&#125;\n    />\n  );\n&#125;;\n\nexport default Editor;\n\n\n\n\n\n\n\nTIP\ncodemirror 支持多种语言的语法高亮，使用 mode 定义当前语言，导入对应的 codemirror&#x2F;mode&#x2F;*下的对应的语言包的 js 文件，就可以实现高亮显示。另外，codemirror 也有很多可配置项，支持 diff 试图（需要另外引入 diff match 包）。codemirror 的宿主是 textarea。还提供了 addon 可配置。\n\nhighlight.jshljs 仅用来做代码块的高亮，是一个小巧且便捷的库。也支持多种语言高亮，不支持编辑。使用方法更像是一个函数，用函数来高亮你的代码块，一般用在博客或者一些网站用来展示一段代码等场景居多。\nmonaco-editormonaco editor 是微软的 vscode 在 browser 里的实现，功能可以参考 vscode，十分强大。也可以通过 npm 来安装到你的 web 项目中。配置上有点麻烦，但是社区有开发者封装的包也比较好用。因为涉及的一些语法提示功能，需要配置 web-worker，还需要 vs 的 loader 来驱动，所以如果是单引入了 monaco，那么不仅需要配置 webpack 的 monaco 的 plugin，可能还要有一个处理 worker 的地方。具体的配法建议 google。\n有个方便使用的包是 @monaco-editor/react ，使用这个包，可谓是开箱即用的，默认导出的模块是 Editor，使用方法当做普通组件一样就行。但是需要注意的是，使用中会加载一个 vs 的 loader，默认是引用的 cdn 的文件，当处于离线环境时，编辑器就会停在 loading 的页面，没法使用。想要在内网或者是离线环境下使用，就得自己把 vs 的文件夹一同打包到 web 项目里，然后在引用 editor 的地方，使用 @monaco-editor/react 提供的 loader 函数，配置 paths 的 vs，使用下载的 vs 文件夹的地址，这样才能使用静态的 loader 文件，完整语法提示功能。\n功能上来看，monaco editor 功能最强大毋庸置疑，光是语法提示在使用上就很方便，很多知名的在线编辑器，比如 codesandbox、bitbucket 等都是使用 monaco 作为编辑器。体验上接近了 vscode 客户端。不过上面提到的包含 loader 的 vs 文件夹，min size 的都有 14M 多，如果你的项目只是需要高亮功能，不需要交互的话，还是推荐选择轻量的 syntax highlight 库来实现。\n","slug":"js-code-editor","date":"2020-11-25T06:40:23.000Z","categories_index":"frontend,react","tags_index":"frontend,react,codemirror","author_index":"Zhongkang Shen"},{"id":"2376683db1311ee594f9efc1800bc966","title":"Jest: JavaScript单元测试快速入门","content":"\n测试意味着什么？在技术术语中，测试意味着检查我们的代码是否符合某些期望。例如，名为transformer的函数，应在给定某些输入的情况下返回预期的输出。\n测试类型很多，这么多术语很快就会让人感到不知所措，简而言之测试分为下面三大类：\n\n单元测试\n整合测试\nUI 测试\n\n本文仅介绍单元测试。\nJest 是什么？Jest 是 JavaScript 测试运行程序，即用于创建、运行和构建测试的 JavaScript 库。\nJest 使用 npm 来安装，你可以将其安装在任意 javascript 项目中,Jest 是当今最受欢迎的测试运行程序之一，也是 React 项目的默认选择。\n我怎么知道要测试什么？初接触测试，即使最简单的测试代码块，也会让初学者懵逼。最常见的问题就是”我怎么知道要测试什么？“。\n如果你正在编写 web 应用程序，那么一个好的切入点就是测试应用程序的每个页面以及每个交互。但是，web 应用程序也由功能和模块之类的代码单元组成，也需要进行测试。\n通常有下面两种情况：\n\n旧项目，没有写过单元测试\n新项目，要从头写单元测试\n\n对于这两种情况，都应同样将测试视为代码的一部分来进行检查，这些代码可以检查给定函数是否产生预期的结果。典型的测试流程如下所示：\n\n导入要测试的功能\n给定输入\n定义期望的输出\n检查函数是否产生预期的输出\n\n就这么简单，如果你按照这个思路考虑，测试将不再可怕：输入-预期输出-输出验证结果\n现在就动手试一试。\n创建项目mkdir getting-started-with-jest &amp;&amp; cd $_\nnpm init -y\n\n通过npm来安装&#96;jest\nnpm i jest --save-dev\n\n修改下package.json中的scripts来方便运行测试\n\"script\": &#123;\n  \"test\": \"jest\"\n&#125;\n\nSpecifications 和 TDD（test-driven development: 测试驱动开发）作为开发人员，一般都比较自信（我写的代码绝对没问题）。但是，当涉及到比较复杂的业务逻辑时，通常没法掌控更多的细节。\n所以我们必须遵循测试用例：即是对构建的内容的书面的或口头的描述。\n下文中，我们写个简单的用例，我们需要写一个函数，该函数需要过滤对象数组，对于每个对象，我们必须检查一个名为”url”的属性，如果该属性的值与给定字符串匹配，则应在结果数组中含括匹配的对象。\n作为一个精通测试的 js 开发人员，你应该遵循测试驱动开发，这是一种在开始编写代码之前必须编写失败测试的准则。\n默认情况下 Jest 会在项目下找名为__tests__的文件夹。\n我们在项目根目录下创建个文件夹，名为__tests__:\nmkdir __tests__\n\n然后在这个文件夹里，新建个测试用例名为filterByTerm.spec.js。用例以.spec.js作为文件后缀，是从Ruby借鉴的作为一种约定。\n下面开始写用例。\nfilterByTerm.spec.js：\ndescribe('Filter function', () => &#123;\n  // test stuff\n&#125;);\n\n第一个接触到的方法是describe，用来包含一个或多个相关的测试方法。之后每次新写用例时，都使用describe来包装。此方法有两个参数，第一个参数是用来描述测试的字符串，第二个参数是包含测试代码的回调函数。\n下一个方法是test，用来写具体的测试代码块。\nfilterByTerm.spec.js：\ndescribe('Filter function', () => &#123;\n  test('it should filter by a search term (link)', () => &#123;\n    // actual test\n  &#125;);\n&#125;);\n\n下面我们来写用例，按照步骤，我们先准备个输入:\nfilterByTerm.spec.js：\ndescribe('Filter function', () => &#123;\n  test('it should filter by a search term (link)', () => &#123;\n    const input = [\n      &#123; id: 1, url: 'https://www.url1.dev' &#125;,\n      &#123; id: 2, url: 'https://www.url2.dev' &#125;,\n      &#123; id: 3, url: 'https://www.link3.dev' &#125;,\n    ];\n  &#125;);\n&#125;);\n\n定义一个预期的输出:\nfilterByTerm.spec.js：\ndescribe('Filter function', () => &#123;\n  test('it should filter by a search term (link)', () => &#123;\n    const input = [\n      &#123; id: 1, url: 'https://www.url1.dev' &#125;,\n      &#123; id: 2, url: 'https://www.url2.dev' &#125;,\n      &#123; id: 3, url: 'https://www.link3.dev' &#125;,\n    ];\n\n    const output = [&#123; id: 3, url: 'https://www.link3.dev' &#125;];\n  &#125;);\n&#125;);\n\n我们使用expect和一个 Jest 的 matcher 来检查函数在调用时是否返回了预期的结果:\nfilterByTerm.spec.js：\ndescribe('Filter function', () => &#123;\n  test('it should filter by a search term (link)', () => &#123;\n    const input = [\n      &#123; id: 1, url: 'https://www.url1.dev' &#125;,\n      &#123; id: 2, url: 'https://www.url2.dev' &#125;,\n      &#123; id: 3, url: 'https://www.link3.dev' &#125;,\n    ];\n\n    const output = [&#123; id: 3, url: 'https://www.link3.dev' &#125;];\n\n    expect(filterByTerm(input, 'link')).toEqual(output);\n  &#125;);\n&#125;);\n\n然后执行npm test，这时候会报个错误ReferenceError: filterByTerm is not defined，这是因为我们先写了用例，还没有写这个名为filterByTerm的函数。下面来写这个函数。\n为了方便，暂时就把函数写在当前的测试文件里面。这个函数比较简单，就是从对象数组中过滤还包含所传标识的对象。\nfunction filterByTerm(inputArr, searchTerm) &#123;\n  return inputArr.filter(function (arrayElement) &#123;\n    return arrayElement.url.match(searchTerm);\n  &#125;);\n&#125;\n\ndescribe('Filter function', () => &#123;\n  test('it should filter by a search term (link)', () => &#123;\n    const input = [\n      &#123; id: 1, url: 'https://www.url1.dev' &#125;,\n      &#123; id: 2, url: 'https://www.url2.dev' &#125;,\n      &#123; id: 3, url: 'https://www.link3.dev' &#125;,\n    ];\n\n    const output = [&#123; id: 3, url: 'https://www.link3.dev' &#125;];\n\n    expect(filterByTerm(input, 'link')).toEqual(output);\n  &#125;);\n&#125;);\n\n然后运行npm test，可以看到测试通过\n PASS  __tests__/filterByTerm.spec.js\n  Filter function\n    ✓ it should filter by a search term (link) (4ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        0.836s, estimated 1s\n\n这就完事儿了吗？并没有，我们来写个失败的用例。\nfunction filterByTerm(inputArr, searchTerm) &#123;\n  return inputArr.filter(function (arrayElement) &#123;\n    return arrayElement.url.match(searchTerm);\n  &#125;);\n&#125;\n\ndescribe('Filter function', () => &#123;\n  test('it should filter by a search term (link)', () => &#123;\n    const input = [\n      &#123; id: 1, url: 'https://www.url1.dev' &#125;,\n      &#123; id: 2, url: 'https://www.url2.dev' &#125;,\n      &#123; id: 3, url: 'https://www.link3.dev' &#125;,\n    ];\n\n    const output = [&#123; id: 3, url: 'https://www.link3.dev' &#125;];\n\n    expect(filterByTerm(input, 'link')).toEqual(output);\n\n    expect(filterByTerm(input, 'LINK')).toEqual(output); // New test\n  &#125;);\n&#125;);\n\n再次执行，会发现报错了，并没有忽略小大写。\n我们修改一下我们函数的实现，让用例跑通：\nfunction filterByTerm(inputArr, searchTerm) &#123;\n  const regex = new RegExp(searchTerm, 'i');\n  return inputArr.filter(function (arrayElement) &#123;\n    return arrayElement.url.match(regex);\n  &#125;);\n&#125;\n\n代码覆盖率在了解代码覆盖率之前，我们先把函数从单元测试中分离出来。\nmkdir src &amp;&amp; cd $_\ntouch filterByTerm.js\n\n把单元测试里的函数代码剪切过来filterByTerm.js\nfunction filterByTerm(inputArr, searchTerm) &#123;\n  if (!searchTerm) throw Error('searchTerm cannot be empty');\n  const regex = new RegExp(searchTerm, 'i');\n  return inputArr.filter(function (arrayElement) &#123;\n    return arrayElement.url.match(regex);\n  &#125;);\n&#125;\n\nmodule.exports = filterByTerm;\n\n那现在假设来了新的接锅侠，写了新的代码：\nfunction filterByTerm(inputArr, searchTerm) &#123;\n  if (!searchTerm) throw Error('searchTerm cannot be empty');\n  if (!inputArr.length) throw Error('inputArr cannot be empty'); // new line\n  const regex = new RegExp(searchTerm, 'i');\n  return inputArr.filter(function (arrayElement) &#123;\n    return arrayElement.url.match(regex);\n  &#125;);\n&#125;\n\nmodule.exports = filterByTerm;\n\n除非告知代码里添加了新的语句，需要写单元测试，不然的话，并不知道要测试哪一块代码。所以就需要一个可以统计代码测试覆盖率的工具来查看，哪些代码有单元测试，哪些没有。\n我们可以在执行 test 时候加上--converage后缀来查看覆盖率，不过在此之前，我们在__tests__/filterByTerm.spec.js里引入我们要测试的函数。\nconst filterByTerm = require('../src/filterByTerm');\n// ...\n\n执行npm test -- --coverage\n PASS  __tests__/filterByTerm.spec.js\n  Filter function\n    ✓ it should filter by a search term (link) (3ms)\n    ✓ it should filter by a search term (uRl) (1ms)\n    ✓ it should throw when searchTerm is empty string (2ms)\n\n-----------------|----------|----------|----------|----------|-------------------|\nFile             |  % Stmts | % Branch |  % Funcs |  % Lines | Uncovered Line #s |\n-----------------|----------|----------|----------|----------|-------------------|\nAll files        |     87.5 |       75 |      100 |      100 |                   |\n filterByTerm.js |     87.5 |       75 |      100 |      100 |                 3 |\n-----------------|----------|----------|----------|----------|-------------------|\nTest Suites: 1 passed, 1 total\nTests:       3 passed, 3 total\n\n可以看到统计结果，第三行没有被覆盖到。\n如果想要代码覆盖率检查始终处于活动状态，我们可以配置package.json\n\"scripts\": &#123;\n  \"test\": \"jest\"\n&#125;,\n\"jest\": &#123;\n  \"collectCoverage\": true\n&#125;,\n\n如果需要可视化的页面查看结果\n\"scripts\": &#123;\n  \"test\": \"jest\"\n&#125;,\n\"jest\": &#123;\n  \"collectCoverage\": true,\n  \"coverageReporters\": [\"html\"]\n&#125;,\n\n现在，每次运行 npm test 时，你都可以看到在项目文件夹下有个coverage新文件夹。可以打开其中的 index.html 来查看覆盖率摘要。\n点击文件名称，可以查看测试详情。\n\n完整的单元测试\nconst filterByTerm = require('../src/filterByTerm');\n\ndescribe('Filter function', () => &#123;\n  test('it should filter by a search term (link)', () => &#123;\n    const input = [\n      &#123; id: 1, url: 'https://www.url1.dev' &#125;,\n      &#123; id: 2, url: 'https://www.url2.dev' &#125;,\n      &#123; id: 3, url: 'https://www.link3.dev' &#125;,\n    ];\n\n    const output = [&#123; id: 3, url: 'https://www.link3.dev' &#125;];\n\n    expect(filterByTerm(input, 'link')).toEqual(output);\n    expect(filterByTerm(input, 'LINK')).toEqual(output);\n  &#125;);\n\n  test('it should filter by a search term (uRl)', () => &#123;\n    const input = [\n      &#123; id: 1, url: 'https://www.url1.dev' &#125;,\n      &#123; id: 2, url: 'https://www.url2.dev' &#125;,\n      &#123; id: 3, url: 'https://www.link3.dev' &#125;,\n    ];\n\n    const output = [\n      &#123; id: 1, url: 'https://www.url1.dev' &#125;,\n      &#123; id: 2, url: 'https://www.url2.dev' &#125;,\n    ];\n\n    expect(filterByTerm(input, 'uRl')).toEqual(output);\n  &#125;);\n\n  test('it should throw when searchTerm is empty string', () => &#123;\n    const input = [];\n    expect(() => &#123;\n      filterByTerm(input, '');\n    &#125;).toThrowError(Error('searchTerm cannot be empty'));\n  &#125;);\n&#125;);\n\n是不是非常直观呢，通过查看单元测试覆盖率，就可以查看哪些代码没有被测试覆盖到。从而针对性的编写单元测试和测试用例。\n","slug":"getting-started-with-javascript-testing","date":"2020-10-14T09:36:45.000Z","categories_index":"frontend,javascript","tags_index":"frontend,javascript,jest","author_index":"Zhongkang Shen"},{"id":"aa47fed830b3b43172f76581df42053e","title":"[夯实基础]使用JavaScript生成表格","content":"使用原生 API 来操作 DOM 是很多技术面试中会问到的问题，这篇文章里，我们不使用任何框架或库，就使用纯原生的 js 来创建一个表格。\n前提你需要具备基本的 HTML 和 JavaScript 知识。\n需求分析我们需要将一份名为”mountains“的数组（Collections），渲染为一个表格。指定每个Object的key为表格的列（Column），每一个Object为一行（Row）。\nObject 结构大概像下面这个样子:\n&#123; name: \"泰山\", height: 1532.7, place: \"山东省泰安市泰山区\" &#125;\n\nname是山名，height是山的海拔，place是山的位置。\n表格的数据源大概是下面这个样子:\nlet mountains = [\n  &#123; name: '泰山', height: 1532.7, place: '山东省泰安市泰山区' &#125;,\n  &#123; name: '嵩山', height: 1491.71, place: '河南省郑州市登封市' &#125;,\n];\n\n我们希望通过这份数据，生成如下网页结构:\n&lt;table>\n  &lt;thead>\n    &lt;tr>\n      &lt;th>名称&lt;/th>\n      &lt;th>海拔&lt;/th>\n      &lt;th>位置&lt;/th>\n    &lt;/tr>\n  &lt;/thead>\n  &lt;tbody>\n    &lt;tr>\n      &lt;td>泰山&lt;/td>\n      &lt;td>1532.7&lt;/td>\n      &lt;td>山东省泰安市泰山区&lt;/td>\n    &lt;/tr>\n    &lt;tr>\n      &lt;td>嵩山&lt;/td>\n      &lt;td>1491.71&lt;/td>\n      &lt;td>河南省郑州市登封市&lt;/td>\n    &lt;/tr>\n  &lt;/tbody>\n&lt;/table>\n\n如上，可以看到这个表格（table），包含一个表格头部 thead（table head），thead 包含一行 tr（table row），这一行里又有三列表头信息 th（table header）。表格又包含了表格主体 tbody（table body），tbody 包含多行，每行又有多个单元格用 td 表示（table cells）。\n分析完需求后，先来创建个 html 文件index.html:\n&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n  &lt;head>\n    &lt;meta charset=\"UTF-8\" />\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    &lt;title>Build a table&lt;/title>\n  &lt;/head>\n  &lt;body>\n    &lt;table>\n      &lt;!-- here goes out data! -->\n    &lt;/table>\n  &lt;/body>\n  &lt;script src=\"build-table.js\">&lt;/script>\n&lt;/html>\n\n创建个 js 文件叫build-table.js和index.html放在同样目录下就行，接下来就在 js 文件中来写主要的代码。\n现在有五岳的数据：\nlet mountains = [\n  &#123; name: '泰山', height: 1532.7, place: '山东省泰安市泰山区' &#125;,\n  &#123; name: '嵩山', height: 1491.71, place: '河南省郑州市登封市' &#125;,\n  &#123; name: '华山', height: 2154.9, place: '陕西省渭南市华阴市' &#125;,\n  &#123; name: '衡山', height: 1300.2, place: '湖南省亨衡阳市南岳区' &#125;,\n  &#123; name: '恒山', height: 2016.1, place: '山西省大同市浑源县' &#125;,\n];\n\n我们的首要目标是想生成表头，那我们知道一个原生的方法createElement()，这个方法会生成一个你往参数里传入的元素。也就是说我们现在用document.createElement(&quot;thead&quot;)就可以生成表头元素了，不过还有更好的方式吗？\n答案是肯定的，我们来看下 MDN 的element table reference，可以看到 table 相关的 DOM interface 叫做HTMLTableElement，有趣的是这个接口下暴露的方法中有个createTHead()。这个方法返回一个 table head element，我们要用一个 table 来关联他。\n// 生成表格头\nfunction generateTableHead(table) &#123;\n  let thead = table.createTHead();\n&#125;\n\nlet table = document.querySelector('table');\ngenerateTableHead(table);\n\n打开index.html，使用 chrome 检查下，就可以看到 table 下已经有 thead 了。拿一组数据出来:\n&#123; name: \"泰山\", height: 1532.7, place: \"山东省泰安市泰山区\" &#125;\n// ...\n\n我们要把这组数据的key转换为表头，按照思路来，那肯定是要在 thead 里添加一行作为表头信息。使用document.createElement(&quot;tr&quot;)吗？不用，HTMLTableRowElement提供了insertRow()方法来插入行，下面来改下generateTableHead函数:\nfunction generateTableHead(table) &#123;\n  let thead = table.createTHead();\n  let row = thead.insertRow();\n&#125;\n\n下面呢，我们要在表头里生成三列，我们遍历给的数据，使用 Object 的 key 来作为 th 的内容，从而生成以 key 作为表头的表格。\nfunction generateTableHead(table, data) &#123;\n  let thead = table.createTHead();\n  let row = thead.insertRow();\n  for (let key of data) &#123;\n    let th = document.createElement('th');\n    let text = document.createTextNode(key);\n    th.appendChild(text);\n    row.appendChild(th);\n  &#125;\n&#125;\n\nlet table = document.querySelector('table');\nlet data = Object.keys(mountains[0]);\n\ngenerateTableHead(table, data);\n\n保存刷新就可以看到出现了表头，包含 name，height 和 place 三个列。现在用同样的思路完成表格内容的创建，我们写个用来生成表格内容的函数：\nfunction generateTable(table, data) &#123;\n  for (let element of data) &#123;\n    let row = table.insertRow();\n    for (key in element) &#123;\n      let cell = row.insertCell();\n      let text = document.createTextNode(element[key]);\n      cell.appendChild(text);\n    &#125;\n  &#125;\n&#125;\n\n现在build-table.js是这样的：\nlet mountains = [\n  &#123; name: '泰山', height: 1532.7, place: '山东省泰安市泰山区' &#125;,\n  &#123; name: '嵩山', height: 1491.71, place: '河南省郑州市登封市' &#125;,\n  &#123; name: '华山', height: 2154.9, place: '陕西省渭南市华阴市' &#125;,\n  &#123; name: '衡山', height: 1300.2, place: '湖南省亨衡阳市南岳区' &#125;,\n  &#123; name: '恒山', height: 2016.1, place: '山西省大同市浑源县' &#125;,\n];\n\nfunction generateTableHead(table, data) &#123;\n  let thead = table.createTHead();\n  let row = thead.insertRow();\n  for (let key of data) &#123;\n    let th = document.createElement('th');\n    let text = document.createTextNode(key);\n    th.appendChild(text);\n    row.appendChild(th);\n  &#125;\n&#125;\n\nfunction generateTable(table, data) &#123;\n  for (let element of data) &#123;\n    let row = table.insertRow();\n    for (key in element) &#123;\n      let cell = row.insertCell();\n      let text = document.createTextNode(element[key]);\n      cell.appendChild(text);\n    &#125;\n  &#125;\n&#125;\n\nlet table = document.querySelector('table');\nlet data = Object.keys(mountains[0]);\ngenerateTableHead(table, data);\ngenerateTable(table, mountains);\n\n保存刷新，我们就可以看到我们的数据已经以表格的形式展现出来了。\n但是，此时我们审查 DOM 的话，就会看到问题，没有 tbody！！！所有 tr 都在 thead 里面。调整一下代码:\n// ...\nlet table = document.querySelector('table');\nlet data = Object.keys(mountains[0]);\ngenerateTable(table, mountains); // 先生成table\ngenerateTableHead(table, data); // 再生成thead\n\n再次保存刷新，\b\b 这次可以看到结构就正常了。\n至此。我们使用纯 js 创建一个表格就完成了。\n","slug":"create-html-table-with-js","date":"2020-10-14T07:11:44.000Z","categories_index":"frontend,javascript","tags_index":"frontend,javascript","author_index":"Zhongkang Shen"},{"id":"b575729d8618cc3713b6023b411791fd","title":"[指南]: JavaScript中的var, let和const","content":"\n\nvar\n块级作用域和全局作用域\n意料之外的全局变量\n重新分配和重新声明\n\n\nlet\n块级作用域\n临时死区\n可以重新赋值，不可以重新声明\n\n\nconst\n块级作用域\n临时死区\n不能重新赋值，不能重新声明\n\n\n\nvarvar用来在 JavaScript 中声明一个变量，该变量遵循以下规则：\n\n函数级作用域(块级作用域)或者全局作用域。\n不受暂时死区(Temporal dead zone)的约束。\n在window对象下创建一个同名的全局属性。\n可重新分配。\n可重新声明。\n\n块级作用域和全局作用域var如果是在全局作用域下出现，则创建一个全局变量，并且也同时在window对象中创建了一个同名的全局属性。\nvar city = 'Beijing';\n\nconsole.log(window.city); // \"Beijing\"\n\n当在函数中使用var声明变量时，则是函数级作用域。\nvar city = 'Beijing';\n\nfunction bubble() &#123;\n  var city = 'Hangzhou';\n  console.log(city);\n&#125;\n\nbubble(); // \"Hangzhou\"\n\nconsole.log(city); // \"Beijing\"\n\nvar具有变量声明提升的特点\nfunction bubble() &#123;\n  city = 'Beijing';\n  console.log(city);\n  var city; // 被提升\n&#125;\n\nbubble(); // \"Beijing\"\n\n意料之外的全局变量没有使用var、let、const声明的变量，默认成为全局变量：\nfunction bubble() &#123;\n  city = 'Beijing';\n  console.log(window.city);\n&#125;\n\nbubble(); // \"Beijing\"\n\n可以通过启用 严格模式 来规避这个问题:\n'use strict';\n\nfunction bubble() &#123;\n  city = 'Beijing';\n  console.log(window.city);\n&#125;\n\nbubble(); // ReferenceError: assignment to undeclared variable city\n\n重新分配和重新声明任何使用var定义的变量，都可以在后面再次声明或是再次赋值。\nredeclaration:\nfunction bubble() &#123;\n  var city = 'Beijing';\n  var city = 'Hangzhou';\n  console.log(city);\n&#125;\n\nbubble(); // \"Hangzhou\"\n\nreassignaton:\nfunction bubble() &#123;\n  var city = 'Beijing';\n  city = 'Hangzhou';\n  console.log(city);\n&#125;\n\nbubble(); // \"Hangzhou\"\n\nlet使用let声明的变量遵循以下规则：\n\n块级作用域\n受临时死区的限制\n不会在window上创建任何属性\n可以重新赋值\n不可以重新声明\n\n块级作用域let声明的变量不会在window上创建任何全局属性\nlet city = 'Beijing';\n\nconsole.log(window.city); // undefined\n\n当在函数内使用let时，该变量的作用域仅限于函数内\nlet city = 'Beijing';\n\nfunction bubble() &#123;\n  let city = 'Hanzhou';\n  console.log(city);\n&#125;\n\nbubble(); // \"Hangzhou\"\n\nconsole.log(city); // \"Beijing\"\n\n当在代码块中使用let，改变量的作用域仅限于代码块中\nlet city = 'Beijing';\n\n&#123;\n  let city = 'Hangzhou';\n  console.log(city); // \"Hangzhou\"\n&#125;\n\nconsole.log(city); // \"Beijing\"\n\nif代码块\nlet city = 'Beijing';\n\nif (true) &#123;\n  let city = 'Hangzhou';\n  console.log(city); // \"Hangzhou\"\n&#125;\n\nconsole.log(city); // \"Beijing\"\n\n如果是var定义的，则不会产生块级作用域\nvar city = 'Beijing';\n\n&#123;\n  var city = 'Hangzhou';\n  console.log(city); // \"Hangzhou\"\n&#125;\n\nconsole.log(window.city); // \"Hangzhou\"\n\n临时死区let声明会提升，但是会加入临时死区。\nfunction bubble() &#123;\n  city = 'Beijing';\n  console.log(city); // TDZ\n  let city;\n&#125;\n\nbubble(); // ReferenceError: can't access lexical declaration 'city' before initialization\n\nTDZ(Temporal dead zone)临时死区用来方式变量在初始化之前被访问。\nfunction bubble() &#123;\n  console.log(city); // TDZ\n  let city = 'Beijing';\n&#125;\n\nbubble(); // ReferenceError: can't access lexical declaration 'city' before initialization\n\n出现上面这个异常错误，就代表出现了临时死区。\n可以重新赋值，不可以重新声明can’t be redeclared:\nfunction bubble() &#123;\n  let city = 'Beijing';\n  let city = 'Hanzhou';\n  console.log(city);\n&#125;\n\nbubble(); // SyntaxError: redeclaration of let city\n\nreassignation:\nfunction bubble() &#123;\n  let city = 'Beijing';\n  city = 'Hangzhou';\n  console.log(city);\n&#125;\n\nbubble(); // \"Hangzhou\"\n\nconst使用const声明的变量遵循以下规则：\n\n块级作用域\n受临时死区的限制\n不创建任何挂载到window上的全局属性\n不可以重新赋值\n不可以重新声明\n\nconst-块级作用域const声明的变量不会在window上创建任何全局属性\nconst city = 'Beijing';\n\nconsole.log(window.city); // undefined\n\n当在函数内使用const时，该变量的作用域仅限于函数内\nconst city = 'Beijing';\n\nfunction bubble() &#123;\n  const city = 'Hanzhou';\n  console.log(city);\n&#125;\n\nbubble(); // \"Hangzhou\"\n\nconsole.log(city); // \"Beijing\"\n\n当在代码块中使用const，改变量的作用域仅限于代码块中\nconst city = 'Beijing';\n\n&#123;\n  const city = 'Hangzhou';\n  console.log(city); // \"Hangzhou\"\n&#125;\n\nconsole.log(city); // \"Beijing\"\n\nif代码块\nconst city = 'Beijing';\n\nif (true) &#123;\n  const city = 'Hangzhou';\n  console.log(city); // \"Hangzhou\"\n&#125;\n\nconsole.log(city); // \"Beijing\"\n\nconst-临时死区const声明会提升，但是会加入临时死区。\nfunction bubble() &#123;\n  city = \"Beijing\";\n  const city;\n&#125;\n\nbubble(); // ReferenceError: can't access lexical declaration 'city' before initialization\n\n不能重新赋值，不能重新声明const声明的变量（常量）不能重新声明，也不能重新赋值。\ncan’t be redeclared\nfunction bubble() &#123;\n  const city = 'Beijing';\n  const city = 'Hangzhou';\n  console.log(city);\n&#125;\n\nbubble(); // SyntaxError: redeclaration of const city\n\ncan’t be reassigned\nfunction bubble() &#123;\n  const city = 'Beijing';\n  city = 'Hangzhou';\n  console.log(city);\n&#125;\n\nbubble(); // TypeError: invalid assignment to const 'city'\n","slug":"javascript-var-let-const","date":"2020-10-13T07:41:45.000Z","categories_index":"frontend,tutorial","tags_index":"frontend,basic","author_index":"Zhongkang Shen"},{"id":"3ca11276a4cccae9aefdd51129835758","title":"React + Typescript！使用react-boilerplate-cra-template创建react项目","content":"React + Typescript！使用 react-boilerplate-cra-template 创建 react 项目Create react app use react-boilerplate-cra-template.1. 使用 cra-template-rb 模板，配合 create-react-app 命令npx create-react-app --template cra-template-rb your-app-name\n\n如果有已经存在的 git 项目，可以先将空的 git 项目 clone 到本地，然后将上面命令最后指定的 your-app-name 更换为本地仓库的目录。例如：\nnpx create-react-app --template cra-template-rb git-repo\n2. 默认有一些示例页面，使用 npm run cleanAndSetup 可以清理。\n3. 配置项目启动的端口项目通过命令 npm start 或 yarn start 来启动，启动端口默认为 3000。可以通过修改项目根目录下的 .env.local 来设置启动的端口。\n# .env.local\nBROWSER=none\nEXTEND_ESLINT=true\nPORT=3030\n\n4. 配置代理(Proxy)为了便于代理的更改，将代理提取为 json 文件。然后使用 setupProxy.js 配置。\n安装依赖 yarn add chalk http-proxy-middleware 或 npm i chalk http-proxy-middleware 可加 -D ，不加也行，create-react-app 会处理的。\n\n\n\n\n\n\n\n\n\n\n\n文件位置: &#x2F;src&#x2F;setupProxy.js (脚手架暂不支持 proxy 为 ts 文件)\n\n\n/**\n * Configure Http Proxy\n */\nconst fs = require('fs');\nconst path = require('path');\nconst chalk = require('chalk');\nconst &#123; createProxyMiddleware &#125; = require('http-proxy-middleware');\n\nconst divider = chalk.gray('\\n-----------------------------------');\n\n// logger\nconst logger = &#123;\n  error: (err) => &#123;\n    console.error(chalk.red(err));\n  &#125;,\n  proxyReversed: (target, apis) => &#123;\n    console.log(\n      `\n        Proxy to $&#123;chalk.bold(target)&#125; $&#123;chalk.green('✓')&#125;$&#123;divider&#125;\n      `\n    );\n    apis.forEach((api) => &#123;\n      console.log(`$&#123;chalk.magenta(api)&#125;`);\n    &#125;);\n    console.log(chalk.gray('-----------------------------------\\n'));\n  &#125;,\n  appStarted: (port, tunnelStarted) => &#123;\n    console.log(`Server started $&#123;chalk.green('✓')&#125;`);\n    if (tunnelStarted) &#123;\n      console.log(`Tunnel initialised $&#123;chalk.green('✓')&#125;`);\n    &#125;\n    console.log(\n      `\n        $&#123;chalk.bold('Access URLs:')&#125;$&#123;divider&#125;\n        Localhost: $&#123;chalk.magenta(`http://localhost:$&#123;port&#125;`)&#125;\n        $&#123;tunnelStarted ? `\\n     Proxy: $&#123;chalk.magenta(tunnelStarted)&#125;` : ''&#125;\n        $&#123;divider&#125;\n        $&#123;chalk.blue(`Press $&#123;chalk.italic('CTRL-C')&#125; to stop`)&#125;\n      `\n    );\n  &#125;,\n&#125;;\n\nconst addProxyMiddleware = (app) => &#123;\n  // proxy path\n  const proxyFilePath = path.resolve(process.cwd(), 'proxy.json');\n  let config = &#123;&#125;;\n\n  if (fs.existsSync(proxyFilePath)) &#123;\n    try &#123;\n      config = JSON.parse(fs.readFileSync(proxyFilePath, 'utf-8'));\n    &#125; catch (error) &#123;\n      logger.error(`Parse ./proxy.json: $&#123;error.message&#125;`);\n      process.exit(0);\n    &#125;\n  &#125;\n\n  try &#123;\n    Object.keys(config).forEach((ck) => &#123;\n      const service = config[ck];\n      service.apis.forEach((api) =>\n        app.use(\n          createProxyMiddleware(api, &#123;\n            target: service.target,\n            logLevel: 'info',\n            changeOrigin: service.hasOwnProperty('changeOrigin')\n              ? service.changeOrigin\n              : true,\n          &#125;)\n        )\n      );\n    &#125;);\n  &#125; catch (err) &#123;\n    logger.error(`Proxy config error: $&#123;err.message&#125;`);\n    process.exit(0);\n  &#125;\n&#125;;\n\nmodule.exports = addProxyMiddleware;\n\nproxy.json 文件新建在项目的根目录下与 package.json 一级。内容格式如下:\n&#123;\n  \"default\": &#123;\n    \"target\": \"http://localhost:8080\",\n    \"apis\": [\"/api/v1/**\"]\n  &#125;,\n  \"user\": &#123;\n    \"target\": \"http://localhost:8081\",\n    \"apis\": [\"/api/v1/user/**\"]\n  &#125;\n&#125;\n\ntarget 为要代理到的后台地址，apis 是需要代理到这个地址的 api。\n5. 使用 sasscra 支持 sass，不过需要安装 sass 的 loader。这里使用 yarn add node-sass 来安装(速度比较慢)。\n安装完成后，即可在项目中创建 .scss 文件。\n\ncss-modules，后缀使用 module.css、module.scss\n创建 styles.module.scss 自动启用 css-module。\n\n\nimport React from 'react';\nimport &#123; Helmet &#125; from 'react-helmet-async';\nimport styles from './styles.module.scss';\n\nexport function HomePage() &#123;\n  return (\n    &lt;>\n      &lt;Helmet>\n        &lt;title>Home Page&lt;/title>\n        &lt;meta name='description' content='A Boilerplate application homepage' />\n      &lt;/Helmet>\n      &lt;div className=&#123;styles.container&#125;>Homepage&lt;/div>\n    &lt;/>\n  );\n&#125;\n\n6. 配置 webpack我们使用 @craco/craco 在 cra 中做自定义配置。首先安装 yarn add @craco/craco ，然后在项目根目录下创建 craco.config.js ，将启动脚本改为使用 craco 启动。\n&#123;\n  \"start\": \"craco start\",\n  \"build\": \"craco build\",\n  \"test\": \"craco test\"\n&#125;\n\n\n配置构建进度条插件（progress-bar-webpack-plugin）\nyarn add progress-bar-webpack-plugin 安装，在 craco.config.js 中配置\nconst ProgressBar = require('progress-bar-webpack-plugin');\n\nmodule.exports = &#123;\n  webpack: &#123;\n    plugins: [new ProgressBar()],\n  &#125;,\n&#125;;\n\n7. 使用 UI 库： ant-design先安装 yarn add antd @ant-design/icons (当前版本 &#x61;&#110;&#x74;&#x64;&#x40;&#x34;&#x2e;&#54;&#x2e;&#x33;, @ant-design&#x2F;&#105;&#99;&#x6f;&#x6e;&#x73;&#64;&#x34;&#46;&#x32;&#x2e;&#x32;)\n\n加载样式，这里不使用直接引入 css 或者 less 文件，而是使用 craco-antd 的插件，一方面可以自动引入样式 less 文件，另一方面也可以支持自定义 antd 的 theme 样式变量。\nyarn add craco-antd\n有三种方式来更改 antd 的主题样式\n\n下图的 less 变量定义，具体变量名看 antd 暴露出的。\n下图的 hack 加载 less 文件方式，变量名同上。\n下图的 aliyunTheme，使用已有的 antd 的主题。\n\n\n\nconst ProgressBar = require('progress-bar-webpack-plugin');\nconst AntdLess = require('craco-antd');\n// const aliyunTheme = require('@ant-design/aliyun-theme');\n\nmodule.exports = &#123;\n  webpack: &#123;\n    plugins: [new ProgressBar()],\n  &#125;,\n  plugins: [\n    // 自定义 antd 主题\n    &#123;\n      plugin: AntdLess,\n      options: &#123;\n        lessLoaderOptions: &#123;\n          lessOptions: &#123;\n            // modifyVars: &#123;\n            //   // '@primary-color': 'green', // less变量定义\n            //   // hack: `true; @import \"$&#123;path.resolve(process.cwd(), 'src/styles/theme')&#125;\"`, // 独立less文件定义\n            // &#125;,\n            // modifyVars: aliyunTheme, // 使用主题\n            javascriptEnabled: true,\n          &#125;,\n        &#125;,\n      &#125;,\n    &#125;,\n  ],\n&#125;;\n\nWarning: findDOMNode is deprecated in StrictMode.\n上述警告需要删除 index.tsx 中的 StrictMode 包裹。\nimport React from 'react';\nimport &#123; Helmet &#125; from 'react-helmet-async';\nimport &#123; Button &#125; from 'antd';\nimport styles from './styles.module.scss';\n\nexport function HomePage() &#123;\n  return (\n    &lt;>\n      &lt;Helmet>\n        &lt;title>Home Page&lt;/title>\n        &lt;meta name='description' content='A Boilerplate application homepage' />\n      &lt;/Helmet>\n      &lt;div className=&#123;styles.container&#125;>\n        &lt;Button type='primary' danger=&#123;true&#125;>\n          Turn off\n        &lt;/Button>\n      &lt;/div>\n    &lt;/>\n  );\n&#125;\n\n如下展示，配置成功。\n\n","slug":"cra-template-rb","date":"2020-09-07T06:18:48.000Z","categories_index":"frontend,react,typescript","tags_index":"frontend,react,typescript","author_index":"Zhongkang Shen"},{"id":"24cc8df004fa0ce0bf9cf8c443843104","title":"使用 concurrently 同时运行多个 npm 命令","content":"我们平时可能需要同时在一个 npm scripts 中运行多个 npm 命令。这时候，我们第一时间想到的 &amp;&amp;，比如 npm run build &amp;&amp; npm start。虽然比较方便，但是很难追踪不同的输出，并且当其中一个进程失败的时候，另外的一个进程仍然在运行。这样就很难排查进程失败的原因是什么。concurrently 就可以帮助我们更好的执行脚本。\n你可以全局安装:\nnpm install -g concurrently\n\n或者作为项目依赖安装:\nnpm install concurrently --save\n\n使用方法:\nconcurrently \"command1 arg\" \"command2 arg\"\n\n在项目中使用，我们只需要在我们的 npm scripts 里添加一个合并的命令:\n\"start\": \"concurrently \\\"command1 arg\\\" \\\"command2 arg\\\"\"\n\n更多文档，详情参考 这里。\n","slug":"concurrently","date":"2020-07-30T07:27:56.000Z","categories_index":"frontend,node","tags_index":"node,npm","author_index":"Zhongkang Shen"},{"id":"e1bb4152919c888976987aa6b85cefd0","title":"基于react-boilerplate脚手架添加前端代理","content":"React-Boilerplate是一个对开发者非常友好的 React 脚手架，官方有很详细的文档，脚手架本身可配置的地方也很多，基本可以满足 React 开发中的自定义需求。本文介绍了如何在此脚手架添加前端 Proxy，使 api 访问能够代理到指定 ip。\n安装开发依赖 http-proxy-middleware前端常用的 npm 包，用来做 node server 代理的。通过 npm 或 yarn 作为开发依赖安装。\nnpm i http-proxy-middleware -D / yarn add http-proxy-middleware -D\n\n在项目根目录添加 proxy.json 文件此文件就是需要代理的 api 和转发到的 ip 以及端口了。具体撰写格式仿照下面:\n&#123;\n  \"default\": &#123;\n    \"api\": \"http://localhost:8080\",\n    \"endpoints\": [\"/api/*\", \"/auth/*\"]\n  &#125;,\n  \"biz\": &#123;\n    \"api\": \"http://localhost:8081\",\n    \"endpoints\": [\"/sys/*\", \"/biz/*\"]\n  &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n* 号会匹配 / 后面所有字符；\n在 server&#x2F;middlewares 文件夹里添加 addProxyMiddlewares.js 文件在这个文件里我们读取最外面的 proxy.json 并生成代理。代码如下:\n/* eslint-disable no-console */\n// const proxy = require('http-proxy-middleware'); // 0.x.x版本用法\nconst &#123; createProxyMiddleware &#125; = require('http-proxy-middleware');\nconst fs = require('fs');\nconst chalk = require('chalk');\nconst logger = require('../logger');\n\n// Proxy middleware\nconst addProxyMiddlewares = (app, proxyPath) => &#123;\n  let proxyConfig = &#123;&#125;;\n  if (fs.existsSync(proxyPath)) &#123;\n    try &#123;\n      proxyConfig = JSON.parse(fs.readFileSync(proxyPath, 'utf-8'));\n    &#125; catch (error) &#123;\n      logger.error(`parse ./proxy.json: $&#123;error.message&#125;`);\n    &#125;\n  &#125;\n\n  try &#123;\n    const servicesKeys = Object.keys(proxyConfig);\n    console.log('proxy config:');\n    console.log(JSON.stringify(proxyConfig, 0, 4));\n    servicesKeys.forEach((key) => &#123;\n      const service = proxyConfig[key];\n      const &#123; api &#125; = service;\n      const logLevel = service.logLevel || 'info';\n      // const Proxy = proxy(&#123; // 0.x.x版本用法\n      //   target: api,\n      //   logLevel,\n      //   changeOrigin: true,\n      // &#125;);\n      const Proxy = createProxyMiddleware(&#123;\n        target: api,\n        logLevel,\n        changeOrigin: true,\n      &#125;);\n      service.endpoints.forEach((endpoint) => &#123;\n        app.all(endpoint, (req, res, next) => &#123;\n          console.log(\n            `$&#123;chalk.bold('->')&#125;: $&#123;chalk.bold(req.url)&#125; to $&#123;chalk.gray(api)&#125;`\n          );\n          return Proxy(req, res, next);\n        &#125;);\n      &#125;);\n    &#125;);\n  &#125; catch (error) &#123;\n    logger.error(`proxy config error: $&#123;error.message&#125;`);\n  &#125;\n&#125;;\n\nmodule.exports = (app, options) => &#123;\n  addProxyMiddlewares(app, options);\n  return app;\n&#125;;\n\n\n\n\n\n\n\n\n\n\n这里用到外层的 logger.js \b 在上一层文件夹里，脚手架自带的，用来在 node 启动服务时，打印一些日志或错误信息用的。\n使用代理中间件在 server/middlewares 文件夹里，找到 frontendMiddleware.js。使用代理包裹 app 实例。具体代码如下：\n/* eslint-disable global-require */\nconst path = require('path');\n\n/**\n * Front-end middleware\n */\nmodule.exports = (app, options) => &#123;\n  const isProd = process.env.NODE_ENV === 'production';\n\n  if (isProd) &#123;\n    const addProdMiddlewares = require('./addProdMiddlewares');\n    addProdMiddlewares(app, options);\n  &#125; else &#123;\n    const webpackConfig = require('../../internals/webpack/webpack.dev.babel');\n    const addDevMiddlewares = require('./addDevMiddlewares');\n    const addProxyMiddlewares = require('./addProxyMiddlewares');\n    const proxyPath = path.resolve(process.cwd(), 'proxy.json');\n    addProxyMiddlewares(app, proxyPath);\n    addDevMiddlewares(app, webpackConfig);\n  &#125;\n\n  return app;\n&#125;;\n\n完成此时就可以在 proxy.json 中添加你想要代理的 api 和 ip 了。然后通过 npm start 启动，可以看到控制台里会打印出代理的 ip 和发送的一些请求。此脚手架还可以通过 PORT=4000 npm start 的方式，指定端口启动。\n","slug":"add-proxy-middleware-based-on-react-boilerplate","date":"2019-09-29T07:49:12.000Z","categories_index":"frontend,react","tags_index":"frontend,javascript,react","author_index":"Zhongkang Shen"},{"id":"9f3a35cb2cc930438770890b12612180","title":"联想zuk z2 pro线刷官方底包","content":"ROM 说明适配机型：联想 zuk z2 pro（z2121）zui 版本：zui 4.0.247安卓版本：8.0刷机类型：线刷包压缩包大小：1.8G包名：Z2121_CN_OPEN_USER_Q00030.1_O_ZUI_4.0.247_ST_181017_qpst.zip包下载地址：ROM 提取码: stf7工具下载地址：刷机工具 提取码: ecmk\n\n\n\n\n\n\n\n\n\n刷机前请注意备份数据。\n过程\n下载 ROM 包和线刷工具，解压工具包。找到 QPST.2.7.434.msi，安装。* 请提前安装 zuk 驱动和 vc 支持库。注意：若双击 qpst 安装时出现下图界面，则需要安装 Microsoft .NET Framework 4.0。\n\n安装完成后，找到 QFIL 程序，打开。\n\n进入 QFIL 的Configuration标签页的FireHoseConfiguration, Device Type 选择UFS，勾选Reset After Download。\n\nSelect Build Type 选择Meta Build，点击Load Content，定位到下载的底包文件夹里的contents.xml，选择确定。\n\nusb 数据线一端先连接电脑，然后手机关机状态下，按住音量上键不松，然后按住电源键的同时数据线插入手机，插入后松开电源键，看到 QFIL 界面出现9008端口时，放开音量上键。\n\n点击Download Content手机会进入升级模式。升级完成后在 status 里会看到Download Succeed的日志带出即为成功。\n\n\n\n\n\n\n\n\n\n\n\n如果一直无法识别 9008 端口，可以尝试一下方法:\n\n开机状态下，进入【开发者选项】开启【允许 USB 调试】，连接电脑使用 cmd（或 adb）命令行工具，输入 adb reboot edl 回车运行，运行成功后手机将重启进入 9008 端口。(注意看手机提示，如果有提示需要允许调试，请允许)\n\n先进入工程模式，进入方式有 2 种：\n\n进入方式 1：关机机状态下【按住音量下+电源键】，先出现白色 ZUK 标志，等待 2s 进入工程模式（全英文界面）;\n进入方式 2：关机状态下【按住音量下】，然后插入数据线，手机震动后放开按键，等待 2s 左右出现工程模式（全英文界面）;\n\n进入工程模式后，插入数据线连接电脑，QFIL 软件上显示 shenqi USB 端口，然后点击【download】触发 9008 端口。\n\n关机状态下【同时按住音量键+电源键+指纹键】，大概震动和重启 8~9 次，看到进入 9008 端口就放开。\n\n准备两根数据线，其中一根自制为工程线，操作如下：\n\n把一根数据线表皮剥开，可以看到里面有红色，白色，黑色，绿色四条线；\n先把黑色和绿色的线剪断，然后把剪断后的黑线和绿线的表皮剥开，露出里面的铜线；\n把黑线和绿线露出的铜线进行短接（也就是缠绕，拧在一起），做成工程线；\n分别把普通数据线和自制工程线事先都连接到电脑，打开 qpst 刷机工具配置好；\n一直按住电源键，先用工程线连接手机，等到手机震动一下之后拔掉并放开电源键；\n手机立即再连接普通的数据线（速度尽可能快），电脑上显示 9008 端口。（注意：如果 QFIL 工具提示 please select an existing port，请点击右上角 select a port，勾选 9008 点击 OK）\n\n\n如果条件有限，可以尝试另一种方式：\n\n把一根数据线表皮剥开，可以看到里面有红色，白色，黑色，绿色四条线；\n然后把黑线和绿线的表皮剥开一段，露出里面的铜线；\n用把黑线和绿线露出的铜线进行短接（可以用金属夹子先夹住）；\n打开 qpst 刷机工具配置好，按住电源键，用这条线连接手机和电脑，等到手机震动一下之后松开短接的铜线；\n如果连接顺利，QFIL 应该也会出现 9008 端口；\n\n\n\n","slug":"lash-rom-on-lenovo-zuk-z2-pro","date":"2019-08-12T13:00:02.000Z","categories_index":"android","tags_index":"android,rom,mobile,hack","author_index":"Zhongkang Shen"},{"id":"35574d9f846376250acde8b17bc4aedf","title":"增加开启关闭代理的可在 Terminal 中执行的函数","content":"# use proxy\nproxy () &#123;\n\texport http_proxy=\"http://127.0.0.1:1087\"\n\texport https_proxy=\"http://127.0.0.1:1087\"\n\techo \"HTTP Proxy On\"\n&#125;\n\n# use clash\nclash () &#123;\n\texport http_proxy=\"http://127.0.0.1:7890\"\n\texport https_proxy=\"http://127.0.0.1:7890\"\n\techo \"ClashX Proxy On\"\n&#125;\n\n# use default\nnoproxy () &#123;\n\tunset http_proxy\n\tunset https_proxy\n\techo \"HTTP Proxy Off\"\n&#125;\n\n搭配 ClashX 或者 SSR 来使用，可以控制 Terminal 中的网络请求是否经过代理。\n\n使用 SSR 的代理 proxy\n使用 ClashX 的代理 clash\n关闭使用代理 noproxy\n\n","slug":"add-terminal-proxy","date":"2019-04-25T07:26:41.000Z","categories_index":"mac","tags_index":"mac,bash,terminal","author_index":"Zhongkang Shen"}]